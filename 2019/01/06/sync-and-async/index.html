<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>同步与异步 | Hellflame</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="basics,"><meta name="description" content="pleased or sad, everything dies with hellflame"><link rel="alternate" href="/atom.xml" title="Hellflame" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="apple-touch-icon" href="/images/favicon.png"><link href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="/icon/iconfont.css"><link rel="stylesheet" href="/css/github-markdown.css"><link rel="stylesheet" href="/css/highlight.css"><script src="/js/util.js"></script><script src="/js/valine.min.js"></script><link href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js" async></script><script src="/js/player.js"></script><link href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script></head><body><div id="app"><div class="header-wrap"><header><div class="site-brand"><div class="site-title"> <a href="/">Hellflame</a></div></div><nav class="site-navigation"><ul class="nav-menu"><li class="nav-item" data-path="/"> <a href="/" target="_self">首页</a></li><li class="nav-item" data-path="/archives/"> <a href="/archives/" target="_self">归档</a></li><li class="nav-item" data-path="/categories/"> <a href="/categories/" target="_self">分类</a></li><li class="nav-item" data-path="/tags/"> <a href="/tags/" target="_self">标签</a></li><li class="nav-item" data-path="/friends/"> <a href="/friends/" target="_self">友链</a></li><li class="nav-item" data-path="/about/"> <a href="/about/" target="_self">关于</a></li><li class="nav-item" data-path="https://github.com/hellflame"> <a href="https://github.com/hellflame" target="_self">Github</a></li></ul></nav><i class="iconfont icon-menu"></i></header></div><script src="/js/navigation.js"></script><div class="container post-index"><div class="post"><div style="position:fixed;right:1em;top:1.5em;cursor:pointer;z-index:999" onclick="toggleTOC()" id="toc"><div style="width:2em;height:2em"><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div></div></div><h1 class="article-title"> <span>同步与异步</span></h1><div class="article-top-meta"> <span>发布 : 2019-01-06</span> <span>分类 : <a href="/categories/basics/">basics</a></span> <span>浏览 : <span class="article-timer">--</span></span></div><div class="article-content"><div class="markdown-body"><p>同步与异步的概念其实并不局限于计算机或者程序中线程或进程之间的同异步，同步与异步这种关系性可以扩展到任意两个<code>过程</code>之间</p><h2 id="过程性"><a href="#过程性" class="headerlink" title="过程性"></a>过程性</h2><p>首先，<code>同步与异步</code> 涉及的对象是多个 <code>过程</code></p><p>过程的范围可能超乎想象，从一个进程的执行过程到一个线程的执行过程可以认为是一个过程，他们可以被认为是程序中最常用的过程。但如果思路开阔，其实 <code>任何占用时间</code> 或者说 <code>需要消耗时间来完成</code> 的事都可以是这里的过程</p><p>在程序中，一个函数的执行是一个过程，一个循环的展开也是一个过程，甚至一个变量的赋值也是一个过程，因为其中涉及到对寄存器的一系列操作。在车道上，车辆运行是一个过程，转动方向盘是一个过程，刹车也是一个过程。事无巨细的每一点一滴都需要消耗时间来完成，可以说过程本身就是时间，不一样的是每个过程的生命周期可能都是不一样的，有的过程先发生，有的过程先结束。就像不同人的人生一样，每个人都有自己的生命周期，自己的过程</p><blockquote><p>真理往往简短，推动万物向前的过程也应该单纯</p></blockquote><p>同步与异步的判定与过程的完整性并没有关系，或者说无论多细致的过程都可以是独立的过程或者被干扰的非独立过程。然而就理论而言，貌似并没有人能找到那个绝对独立的过程，或者说被干扰最少的过程，这个过程也许就是人们追寻的万物的本源，一切的驱动力。然而人类无法依靠测试的手段来找寻这个过程的存在，因为没人没见过薛定谔的猫</p><p>如果存在一个独立的过程，那它一定是自我同步的，原子的；如果存在多个独立的过程，那么这些过程之间就是异步的关系。如果两个过程之间产生了干扰，即为 <code>同步过程</code> ，使得两个过程产生了联系。多数情况下，这种联系都不是单一驱动因素(甚至是间接的因素)造成的，不过对于关注的过程而言，可以假定这个同步过程是明确的。</p><h3 id="确定过程"><a href="#确定过程" class="headerlink" title="确定过程"></a>确定过程</h3><p>在关系性(或者说 <code>因果</code> )明确的情况下，两个原子过程如果是同步的，一定是一个过程的 <code>结束</code> 带来了另一个过程的 <code>开始</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment"># 过程1: 给 a 赋值 1</span></span><br><span class="line">a += <span class="number">1</span>  <span class="comment"># 过程2: 让 a 自增 1</span></span><br></pre></td></tr></table></figure><p>上述两个过程，如果解释器正确执行(即因果明确)的情况下，赋值过程的结束将带来自增过程的开始。在得到 <code>a = 2</code> 的整个过程中包含了一次明显的同步过程，有明确的 <code>先后顺序</code>，是一段确定过程。从中可以得到两点：</p><ol><li>多个过程的同步可以看作是一个完整过程，一个完整过程可以拆分为多个同步过程</li><li>多个原子过程如果是同步的，则这是一个确定过程</li></ol><p>还有隐含的一点就是：后开始的过程需要等待上一个过程结束，如果这些过程发生在同一时间轴上，则时间就会被消耗在 <code>等待</code> 上。</p><h3 id="随机过程"><a href="#随机过程" class="headerlink" title="随机过程"></a>随机过程</h3><p>多个异步过程放在一起，可以当作一系列的随机过程。如果他们具有一定的统计学分布，那背后一定存在某种同步。</p><p>随机过程无法掌握，就像多个异步过程无法确定哪一个先开始，哪一个先结束。</p><p>真正的异步的确无法得知其确切的开始与结束。如果知道，那在知道这些过程开始之前一定进行了更大范围甚至更高维度的外部同步。异步，代表了不确定性，就像薛定谔的猫一样，有辣么多猫，谁都不知道过程到了哪一步，直到以某种方式进行干预(测试)，打破随机过程，将异步过程与观察者<a href="#同步过程">同步</a></p><blockquote><p>虽然说了辣么多，但同步与异步讨论的其实过程之间的 <code>关系性</code> ，以上，只是为了将过程的概念从程序中的进程、线程等过程进行拓展，以免思维被束缚</p><p>抛开关系性说同步、异步都是在耍流氓</p></blockquote><h2 id="关系性"><a href="#关系性" class="headerlink" title="关系性"></a>关系性</h2><p>有了过程，过程之间就会有这样那样的关系，直接或者间接的关系。<code>同步与异步</code> 说的一直都是 <code>过程</code> 之间的 <code>关系</code></p><ol><li>如果存在因果关系，则过程之间为 <code>同步关系</code></li><li>如果没有任何关系，则过程之间为 <code>异步关系</code></li></ol><p>给定一个过程:</p><ol><li>如果它是所有因果的起点，那么可以说它是 <code>自同步</code> 的，因为它是万物的起因，也可以说它是异步的，因为它跟其他过程毫无关系，是自驱的过程 (万物的起点与万物的关系)</li><li>否则它既不能说同步，也不能说异步，因为 <code>同异步</code> 指的是过程之间的关系性，无法独立存在</li></ol><p>所以，一个过程，除非它解释了万物存在的理由，那么就无法用同步与异步进行描述，无论如何都需要一个参照</p><p>这种关系性存在以下特点：</p><ol><li><code>相对性</code></li><li><code>复杂性</code></li></ol><h3 id="相对性"><a href="#相对性" class="headerlink" title="相对性"></a>相对性</h3><p>两个过程之间是同步关系还是异步关系，与观察尺度有关。往往在小尺度上的异步，在大尺度下其实是同步的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p1</span><span class="params">(args)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p2</span><span class="params">(args)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>如果仅看上述例子，谁也不知道 <code>p1</code> 与 <code>p2</code> 谁先被调用，甚至都不被调用，但是如果加上下面的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = p1(p2())</span><br></pre></td></tr></table></figure><p>那么两个过程的执行先后就确定了下来</p><p>对于更加复杂的调用环境，要理出两个过程之间的同步关系则要更难一些，甚至不可能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> random() &gt; <span class="number">0.5</span>:</span><br><span class="line">    p1(p2())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p2(p1())</span><br></pre></td></tr></table></figure><p>这个时候，两个的执行顺序变成了随机的，虽然这个顺序具有统计学概率上的确定，但是在过程结束之前，谁都不知道究竟会发生什么</p><p>也就是说，如果将参考换为彼此两个过程，除非两者存在直接的联系，否则都可以看作是异步过程；如果将参考换为两者共同的背景，则可以看作是一个同步过程，有环境作为两者共同的因果</p><h3 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h3><p>复杂性来源与过程本身的复杂性以及因果的复杂性</p><ol><li>过程本身可以拆分为更小的过程，更小的过程之间拥有着各种同步关系，小范围的同步才能形成最终的过程</li><li>因果不一定简单的直接关系，多见为间接关系(比如亚马逊的蝴蝶煽动翅膀这个过程导致宇宙坍塌等等)，因果并不直观</li></ol><h2 id="同步过程"><a href="#同步过程" class="headerlink" title="同步过程"></a>同步过程</h2><p>因为有着各种各样的过程需要我们组合为自己需要的过程，所以需要 <code>同步过程</code> 来联系各个简单过程。</p><p>建立两个过程之间的同步关系，本质上是让两者建立因果</p><p>建立因果的方式有两种：</p><ol><li>直接因果 (彼之果即为此之因)</li><li>间接因果 (媒妁之言)</li></ol><p>直接因果的关系往往直观明了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p1</span><span class="params">(args)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p2</span><span class="params">(args)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">p1(p2())</span><br></pre></td></tr></table></figure><p><code>p2</code> 的果即为 <code>p1</code> 的因</p><p>间接因果则需要媒介</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p1</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">p2</span><span class="params">(b)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">p1(x)</span><br><span class="line">p2(x)</span><br></pre></td></tr></table></figure><blockquote><p> 多进程或多线程中的同步也是通过间接因果的方式进行</p></blockquote><p>函数式编程中则大多数采用直接因果，并且尽量避免一个执行过程带来多种影响，甚至是影响环境上下文。也就是单因果的简单形式，可以使得整个过程的目的尽量单一，专注于目标因果</p><p>命令式编程则比较容易在过程中导致意想不到的因果，干扰了产生的结果，给人一种异步的错觉，难以捉摸</p><hr><p>总而言之</p><blockquote><p>异步本身并不复杂，复杂的是如何将将异步的过程同步起来</p></blockquote></div></div><div class="copy-right"><div class="markdown-body"><blockquote> 本文作者 : hellflame<br> 原文链接 : <a href="">https://hellflame.github.io/2019/01/06/sync-and-async/</a><br> 版权声明 : 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</blockquote></div></div><div class="social-share" style="margin-top:-2rem" data-wechat-qrcode-title="<p>微信扫一扫</p>" data-wechat-qrcode-helper="<p>微信右上角, 扫一扫分享</p>" data-sites="qzone, qq, weibo, facebook, twitter"> <span style="color:#6b7487;font-size:1.4rem">分享到:</span></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js" async></script><div class="article-footer"><div class="article-meta pull-left"><span></span></div><div class="article-meta pull-right"></div></div></div><aside id="sidebar"><p id="sidebar-header"></p><ol id="sidebar-toc"></ol></aside><script async>getTOC().length||$("#toc").remove()</script><nav class="post-navigation"><div class="nav-pre"><i class="iconfont icon-prev"></i> 上一篇: <a href="/2018/12/31/2018-end/" target="_self">在即将结束的2018年</a></div><div class="nav-next"> 下一篇: <a href="/2019/01/13/blocking-vs-non-blocking/" target="_self">阻塞与非阻塞</a><i class="iconfont icon-next"></i></div></nav><a href="#comment" class="comment-anchor"></a><div class="comment-title"><i class="iconfont icon-footprint"></i> 留下足迹<i class="iconfont icon-footprint"></i></div> <a style="margin-bottom:1em;display:block;cursor:pointer" onclick="gotoComment()">点击通过issue留言</a><div id="vcomments"></div><script defer="defer">new Valine({el:"#vcomments",appId:"a",appKey:"b",notify:!1,verify:!1,avatar:"robohash",placeholder:"不填邮箱，网址, 也能收到回复哦♪(^∇^*)\n当然也不一定会回复-_-",path:getRealPath()})</script><script defer="defer">
   function gotoComment() {
    location.href = `https://github.com/hellflame/hellflame.github.io/issues/new?title=关于%0A“%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5”&body=%23%23%23%20[原文地址](https://hellflame.github.io/2019/01/06/sync-and-async/)%0A%0A%23%23%23%20想说的话(问题/支持/异议)%20%20%0A%0A${document.getElementById('veditor').value}`
   }
   document.onreadystatechange = (e) => {
     if(document.readyState === 'complete') {
      setTimeout(() => {
        const target = document.getElementsByClassName("vsubmit vbtn")[0]
        target.outerHTML = target.outerHTML
        setTimeout(() => {
          document.getElementsByClassName("vsubmit vbtn")[0].addEventListener('click', gotoComment)
          console.log("event replaced")
        }, 1000)
        document.getElementsByClassName("power txt-right")[0].innerHTML = "Once powered by Valine"
      }, 1000)
     }
   }
 </script></div><footer><p class="site-info"> 博客已萌萌哒运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span><br> Theme - <a target="_blank" href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With 💗 | Powered by GodBMW & hellflame<br></p></footer><script src="/js/footer.js"></script><script>updateUptime(2016,3,27)</script><div class="back-to-top hidden"><span><i class="iconfont icon-60"></i><span></span> %</span></div><script src="/js/component/back-to-top.js"></script></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script src="/js/mathjax.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.js" async></script><script async src="/js/fancybox.js"></script></body></html>