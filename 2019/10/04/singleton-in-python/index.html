<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>解析Python中的单例 | Hellflame</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="basics,python,"><meta name="description" content="pleased or sad, everything dies with hellflame"><link rel="alternate" href="/atom.xml" title="Hellflame" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="apple-touch-icon" href="/images/favicon.png"><link href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="/icon/iconfont.css"><link rel="stylesheet" href="/css/github-markdown.css"><link rel="stylesheet" href="/css/highlight.css"><script src="/js/util.js"></script><script src="/js/valine.min.js"></script><link href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js" async></script><script src="/js/player.js"></script><link href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script></head><body><div id="app"><div class="header-wrap"><header><div class="site-brand"><div class="site-title"> <a href="/">Hellflame</a></div></div><nav class="site-navigation"><ul class="nav-menu"><li class="nav-item" data-path="/"> <a href="/" target="_self">首页</a></li><li class="nav-item" data-path="/archives/"> <a href="/archives/" target="_self">归档</a></li><li class="nav-item" data-path="/categories/"> <a href="/categories/" target="_self">分类</a></li><li class="nav-item" data-path="/tags/"> <a href="/tags/" target="_self">标签</a></li><li class="nav-item" data-path="/friends/"> <a href="/friends/" target="_self">友链</a></li><li class="nav-item" data-path="/corner-story/"> <a href="/corner-story/" target="_self">转角杀</a></li><li class="nav-item" data-path="/about/"> <a href="/about/" target="_self">关于</a></li><li class="nav-item" data-path="https://github.com/hellflame"> <a href="https://github.com/hellflame" target="_self">Github</a></li></ul></nav><i class="iconfont icon-menu"></i></header></div><script src="/js/navigation.js"></script><div class="container post-index"><div class="post"><div style="position:fixed;right:1em;top:1.5em;cursor:pointer;z-index:999" onclick="toggleTOC()" id="toc"><div style="width:2em;height:2em"><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div></div></div><h1 class="article-title"> <span>解析Python中的单例</span></h1><div class="article-top-meta"> <span>发布 : 2019-10-04</span> <span>分类 : <a href="/categories/basics/">basics</a></span> <span>浏览 : <span class="article-timer">--</span></span></div><div class="article-content"><div class="markdown-body"><p>单例是软件设计模式中比较常用的模式，也是最方便实现的一种模式。正是因此，其实现方式也是最能够体现一个人对python基础知识的掌握情况的标尺</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>每一种单例的实现方式都会有很多可以联系到的基础知识</p><p>以下根据该单例存储的位置范畴由大到小依次说明</p><h3 id="1-全局存储"><a href="#1-全局存储" class="headerlink" title="1. 全局存储"></a>1. 全局存储</h3><p>俗称懒汉模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">Singleton = _Singleton()  <span class="comment"># 想要的单例</span></span><br></pre></td></tr></table></figure><p>当需要使用这个单例时，直接使用 <code>Singlton</code> 实例即可。最简单的情况是在直接使用这个单例，无论是在同一段代码还是以包的形式引用。稍微有点区别的是，以包的形式引用的话，还需要知道 <code>import</code> 这个语法引入变量是单例的，保证了 <code>Singleton</code> 变量地址不发生变化。更妙的是，这段代码不会产生竞争条件，也就是说不会有多线程环境下多次实例化的情况(正常使用的话)。</p><p>然而，如果使用 <code>reload</code> 重新加载这个包含单例的包时，将会产生新的实例。还有另一点，一般不希望在全局存在过多变量，可能在无意中造成不需要的单例的创建，换句话说就是，这种单例不容易由自己决定在什么时候创建，除非你很清楚自己在做什么。最后，这种模式下如果文档中说明不清晰，或者跟其他开发人员交流不够明白，有可能导致手动再创建一个实例，因为 <code>_Singleton</code> 这个类是可以手动再实例化的。</p><blockquote><p>虽然全局存储的形式看上去问题挺多，但这种方式其实揭示了单例模式的通行做法—— 保存实例</p><p>其他创建单例的形式无非是让这个过程变得更加安全和健壮了而已</p></blockquote><h3 id="2-静态变量存储"><a href="#2-静态变量存储" class="headerlink" title="2. 静态变量存储"></a>2. 静态变量存储</h3><p>将实例存储为静态变量的方式将该实例的访问权限缩小为通过类及其实例，相对全局而言提升了一层抽象。据我观察，这也是实现形式最多的一种方式，也是隐藏问题最多的一种。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">  _lock = Lock()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(cls, <span class="string">"__instance__"</span>):</span><br><span class="line">      <span class="keyword">return</span> cls.__instance__</span><br><span class="line">    <span class="keyword">with</span> Singleton._lock:</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">"__instance__"</span>):</span><br><span class="line">        cls.__instance__ = object.__new__(cls)</span><br><span class="line">    <span class="keyword">return</span> cls.__instance__</span><br></pre></td></tr></table></figure><p>这里主要利用了 <code>__new__</code> 方法控制实例的创建过程，但是有几个需要注意的地方</p><h4 id="1-新式类"><a href="#1-新式类" class="headerlink" title="1) 新式类"></a>1) 新式类</h4><p>这个问题存在于python2.7及以下</p><p>也就是说这个类必须是 <code>object</code> 的子类，否则 <code>__new__</code> 方法将失效。说白了，<code>__new__</code> 方法是 <code>object</code> 给的</p><h4 id="2-静态变量名"><a href="#2-静态变量名" class="headerlink" title="2) 静态变量名"></a>2) 静态变量名</h4><p>静态变量的名字不能是私有变量，也就是说不能偷懒给全局变量命名为 <code>__instance</code></p><p>因为会被重写为 <code>_Singleton__instance</code> ，也就是说 <code>hasattr(cls, &quot;__instance__&quot;)</code> 永远都是 <code>False</code> ，因此每次创建实例时都会重建实例</p><p>为了避免这种隐含问题，减少动态属性的使用，一般也会这么写:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">  _lock = Lock()</span><br><span class="line">  _instance = <span class="keyword">None</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> cls._instance:</span><br><span class="line">      <span class="keyword">return</span> cls._instance</span><br><span class="line">    <span class="keyword">with</span> Singleton._lock:</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> cls._instance:</span><br><span class="line">        cls._instance = object.__new__(cls)</span><br><span class="line">    <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure><h4 id="3-初始化方法重复执行"><a href="#3-初始化方法重复执行" class="headerlink" title="3) 初始化方法重复执行"></a>3) 初始化方法重复执行</h4><p><code>__init__</code> 方法作为初始化方法，在每次创建实例完成后都会默认执行，也就是在 <code>__new__</code> 之后自动执行，所以如果有什么只希望在单例创建时执行的动作一定不能直接放在 <code>__init__</code> 中</p><p>所以这里也就有了其他写法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">  _lock = Lock()</span><br><span class="line">  _instance = <span class="keyword">None</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> cls._instance:</span><br><span class="line">      <span class="keyword">return</span> cls._instance</span><br><span class="line">    <span class="keyword">with</span> Singleton._lock:</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> cls._instance:</span><br><span class="line">        cls._instance = cls.get_instance()</span><br><span class="line">    <span class="keyword">return</span> cls._instance</span><br><span class="line">  </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_instance</span><span class="params">(cls)</span>:</span>  <span class="comment"># 作用为取代 __init__ 兼顾创建实例</span></span><br><span class="line">    <span class="comment"># do something heavy</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> object.__new__(cls)</span><br></pre></td></tr></table></figure><p>以及这种写法的退化写法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">  _lock = Lock()</span><br><span class="line">  _instance = <span class="keyword">None</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_instance</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> cls._instance:</span><br><span class="line">      <span class="keyword">return</span> cls._instance</span><br><span class="line">    <span class="keyword">with</span> cls._lock:</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> cls._instance:</span><br><span class="line">        <span class="comment"># do something heavy</span></span><br><span class="line">        <span class="keyword">import</span> time</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line"> </span><br><span class="line">instance = Singleton.get_instance()  <span class="comment"># 想要的单例需要这样生成</span></span><br></pre></td></tr></table></figure><p>其实就是使用类方法代替了 <code>__new__</code> 方法，存储了一个实例到静态变量 <code>_instance</code> 。当然，比较不爽的地方就是单例的获取只能通过调用类方法 <code>get_instance</code> 获得</p><h4 id="4-单例模式不可继承"><a href="#4-单例模式不可继承" class="headerlink" title="4) 单例模式不可继承"></a>4) 单例模式不可继承</h4><p>这里强调是模式不可继承，也就是说父类是单例模式，子类不会不经修饰就成为天然单例模式。而且对于简单的继承，可能会出大问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">  _lock = Lock()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(cls, <span class="string">"__instance__"</span>):</span><br><span class="line">      <span class="keyword">return</span> cls.__instance__</span><br><span class="line">    <span class="keyword">with</span> Singleton._lock:</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">"__instance__"</span>):</span><br><span class="line">        cls.__instance__ = object.__new__(cls)</span><br><span class="line">    <span class="keyword">return</span> cls.__instance__</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">  key = <span class="string">"B"</span></span><br><span class="line"></span><br><span class="line">Singleton()</span><br><span class="line">B().key  <span class="comment"># AttributeError: 'Singleton' object has no attribute 'key'</span></span><br></pre></td></tr></table></figure><p>由于 <code>B</code> 与 <code>Singleton</code> 的实例共享 <code>__instance__</code> 静态变量，所以由于 <code>Singleton</code> 先实例化，导致 <code>B</code> 的实例其实还是 <code>Singleton</code> 的实例</p><p>正确的继承方式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">  _lock = Lock()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(cls, <span class="string">"__instance__"</span>):</span><br><span class="line">      <span class="keyword">return</span> cls.__instance__</span><br><span class="line">    <span class="keyword">with</span> Singleton._lock:</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">"__instance__"</span>):</span><br><span class="line">        cls.__instance__ = object.__new__(cls)</span><br><span class="line">    <span class="keyword">return</span> cls.__instance__</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">  key = <span class="string">"B"</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line"></span><br><span class="line">Singleton()</span><br><span class="line">B().key</span><br><span class="line">B().__instance__</span><br></pre></td></tr></table></figure><p>当然，自然有一种可以继承单例模式的方式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">  _lock = Lock()</span><br><span class="line">  _instance = <span class="keyword">None</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_instance</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> cls._instance:</span><br><span class="line">      <span class="keyword">return</span> cls._instance</span><br><span class="line">    <span class="keyword">with</span> cls._lock:</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> cls._instance:</span><br><span class="line">        <span class="comment"># do something heavy</span></span><br><span class="line">        <span class="keyword">import</span> time</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">Singleton.get_instance()</span><br><span class="line">A.get_instance()</span><br></pre></td></tr></table></figure><p>不过这种方法看起来还是有那么一点丑，所以还有一种稍微高级一点的方式，那就是 <code>元类</code> 。不过元类在python2和python3之间差异较大，所以是不通用的，但是原理是类似的。以下以 <code>python2</code> 作为例子</p><p>元类作为类的类，本质上只是给出了类创建时候的模板，最终还是依靠类本身的特性实现的。可以看看如下例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">    _lock = Lock()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">      <span class="keyword">if</span> hasattr(cls, <span class="string">"__instance__"</span>):</span><br><span class="line">        <span class="keyword">return</span> cls.__instance__</span><br><span class="line">      <span class="keyword">with</span> _lock:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">"__instance__"</span>):</span><br><span class="line">          cls.__instance__ = object.__new__(cls)</span><br><span class="line">      <span class="keyword">return</span> cls.__instance__</span><br><span class="line">    attrs[<span class="string">"__new__"</span>] = new</span><br><span class="line">    <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonA</span><span class="params">(object)</span>:</span></span><br><span class="line">  __metaclass__ = SingletonMeta</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonB</span><span class="params">(object)</span>:</span></span><br><span class="line">  __metaclass__ = SingletonMeta</span><br></pre></td></tr></table></figure><p>上述例子本质上还是依赖 <code>__new__</code> 方法实现，只是将 <code>__new__</code> 方法的实现模板化，使用元类实现类的量产</p><h3 id="3-外部变量存储"><a href="#3-外部变量存储" class="headerlink" title="3. 外部变量存储"></a>3. 外部变量存储</h3><p>一提到外部变量，那么就会提到闭包，一提到闭包，就会说到装饰器。由于装饰器的本质其实都是可执行对象(大多数情况下都说的是函数)，所以以下以普通装饰器为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(name)</span>:</span></span><br><span class="line">  _instance = &#123;&#125;</span><br><span class="line">  _lock = Lock()</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">cls_wrapper</span><span class="params">(cls)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(cls)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">      <span class="keyword">if</span> name <span class="keyword">in</span> _instance:</span><br><span class="line">        <span class="keyword">return</span> _instance[name]</span><br><span class="line">      <span class="keyword">with</span> _lock:</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> _instance:</span><br><span class="line">        	_instance[name] = cls(*args, **kwargs)</span><br><span class="line">      <span class="keyword">return</span> _instance[name]</span><br><span class="line">    <span class="keyword">return</span> init_wrapper</span><br><span class="line">  <span class="keyword">return</span> cls_wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton("A")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：这里假设对python中的字典结构进行加key与查询key的操作是线程安全的</p></blockquote><p>在这种模式下创建单例不再需要一个一个的手写，而是通过装饰器进行包装。这种方式的强大之处在于即使一个已经写好的类不是单例，也可以在外部强行转变为单例。这个例子里可能有一些地方需要特别指出(并不是无意为之)</p><blockquote><p>关于装饰器的一些问题在另一篇文章中会详细整理</p></blockquote><h4 id="1-这是一个带参数的装饰器"><a href="#1-这是一个带参数的装饰器" class="headerlink" title="1) 这是一个带参数的装饰器"></a>1) 这是一个带参数的装饰器</h4><p>首先，这个参数的作用是作为实例在外部字典 <code>_instance</code> 中的key，其次这个key可以通过其他方式获取(也就是说可以用不带参数的装饰器实现)。当然，如果在项目中就只有一个类需要作为单例来使用，可以将key固定为 <code>instance</code> 类似的字符串(虽然我觉得没有多少人会这么做)，甚至将整个实例占用单个外部变量(但是如果是修改外部变量会涉及到内外部作用域的问题，会用到引用传递或者 <code>nonlocal</code> 等)</p><p>如何让 <code>singleton</code> 不带参数使用？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">  _instance = &#123;&#125;</span><br><span class="line">  _lock = Lock()</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># name = __file__ + cls.__name__  # 在交互式shell环境中请去掉 __file__</span></span><br><span class="line">  name = repr(cls)  <span class="comment"># 这个name可能没有上面那么好看，但是好用而且通用 =.=</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @wraps(cls)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init_wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> name <span class="keyword">in</span> _instance:</span><br><span class="line">      <span class="keyword">return</span> _instance[name]</span><br><span class="line">    <span class="keyword">with</span> _lock:</span><br><span class="line">      <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> _instance:</span><br><span class="line">        _instance[name] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> _instance[name]</span><br><span class="line">  <span class="keyword">return</span> init_wrapper</span><br></pre></td></tr></table></figure><p>这里用到一个可能不存在的全局变量 <code>__file__</code> ，是为了防止在不同python文件中存在同名的类，如果不觉得key丑的话 <code>name = repr(cls)</code> 也可以(其实这样的代码反而看起来很清晰=。=)</p><h4 id="2-wraps装饰单例类"><a href="#2-wraps装饰单例类" class="headerlink" title="2) wraps装饰单例类"></a>2) wraps装饰单例类</h4><p>wraps的作用在于恢复被装饰类的基本元信息(对，不仅可以恢复函数的元信息，还可以恢复类的元信息)，默认情况下会保留 <code>__module__</code>, <code>__name__</code>, <code>__doc__</code> 三个元变量数据</p><h4 id="3-线程锁-Lock"><a href="#3-线程锁-Lock" class="headerlink" title="3) 线程锁 Lock"></a>3) 线程锁 Lock</h4><p><code>_lock</code> 锁实例在每次装饰类时实例化，在 <code>with _lock</code> 时控制代码片段访问序列。在一开始首先判断实例是否创建，如果已经创建，则立即返回该实例；如果没有创建，则通过加锁方式创建单例。</p><p>在锁中又判断一次该实例是否创建，是有必要的，考虑如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Delay</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>当多个线程同时开始实例化时都会发现 <code>_instance</code> 中无该实例，在锁的安排下，会依次进入临界区，创建实例，但是这个过程要等待10s之久，所有的线程一定都会尝试一遍创建实例，如果不判断实例是否已经被别的线程创建了，那一定会出现多次实例化。当然，最终的确只会残留一个实例。</p><p>所以，锁 + 存在判断是为了在多线程环境下，从始至终只生成一个正确的实例。</p><h4 id="4-这是一个装饰器"><a href="#4-这是一个装饰器" class="headerlink" title="4) 这是一个装饰器"></a>4) 这是一个装饰器</h4><p>意味着单例被使用函数创建出来，被装饰的单例类再也不是类(至少不是表面上看起来的类)，而是函数，最简单的验证方式就是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type(A)  <span class="comment"># function</span></span><br></pre></td></tr></table></figure><p>因为此时类已经被替换成了 <code>cls_wrapper</code> (带参数) 或者 <code>init_wrapper</code> (不带参数)了</p><p>所以丢失了原来用类来判断的能力，比如 <code>isinstance</code> ，<code>__class__</code> 等等</p><h4 id="5-初始化仅执行一次"><a href="#5-初始化仅执行一次" class="headerlink" title="5) 初始化仅执行一次"></a>5) 初始化仅执行一次</h4><p>和上一类实现方式不一样的是，这里的单例只会执行一次初始化操作。某种意义上算是很方便的一个特性</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>实际情况中，每个人都会根据自己的需求进行单例的实践，甚至多种方式组合使用。不过创建单例的思想一直都没有变过：常驻内存+线程安全</p></div></div><div class="copy-right"><div class="markdown-body"><blockquote> 本文作者 : hellflame<br> 原文链接 : <a href="">https://hellflame.github.io/2019/10/04/singleton-in-python/</a><br> 版权声明 : 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</blockquote></div></div><div class="social-share" style="margin-top:-2rem" data-wechat-qrcode-title="<p>微信扫一扫</p>" data-wechat-qrcode-helper="<p>微信右上角, 扫一扫分享</p>" data-sites="qzone, qq, weibo, facebook, twitter"> <span style="color:#6b7487;font-size:1.4rem">分享到:</span></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js" async></script><div class="article-footer"><div class="article-meta pull-left"><span><i class="iconfont icon-06tags"></i> 标签: <span class="span--tag"><a href="/tags/python/">#python</a></span></span></div><div class="article-meta pull-right"></div></div></div><aside id="sidebar"><p id="sidebar-header"></p><ol id="sidebar-toc"></ol></aside><script async>getTOC().length||$("#toc").remove()</script><nav class="post-navigation"><div class="nav-pre"><i class="iconfont icon-prev"></i> 上一篇: <a href="/2019/09/30/guilin-park-2/" target="_self">桂林公园(二)</a></div><div class="nav-next"> 下一篇: <a href="/2019/10/05/decorators-in-python/" target="_self">解析Python中的装饰器</a><i class="iconfont icon-next"></i></div></nav><a href="#comment" class="comment-anchor"></a><div class="comment-title"><i class="iconfont icon-footprint"></i> 留下足迹<i class="iconfont icon-footprint"></i></div> <a style="margin-bottom:1em;display:block;cursor:pointer" onclick="gotoComment()">通过issue留言</a><div id="vcomments"></div><script defer="defer">new Valine({el:"#vcomments",appId:"a",appKey:"b",notify:!1,verify:!1,avatar:"robohash",placeholder:"不填邮箱，网址, 也能收到回复哦♪(^∇^*)\n当然也不一定会回复-_-",path:getRealPath()})</script><script defer="defer">
   function gotoComment() {
    location.href = `https://github.com/hellflame/hellflame.github.io/issues/new?title=关于%0A“%E8%A7%A3%E6%9E%90Python%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B”&body=%23%23%23%20[原文地址](https://hellflame.github.io/2019/10/04/singleton-in-python/)%0A%0A%23%23%23%20想说的话(问题/支持/异议)%20%20%0A%0A${document.getElementById('veditor').value}`
   }
   document.onreadystatechange = (e) => {
     if(document.readyState === 'complete') {
      setTimeout(() => {
        const target = document.getElementsByClassName("vsubmit vbtn")[0]
        target.outerHTML = target.outerHTML
        setTimeout(() => {
          document.getElementsByClassName("vsubmit vbtn")[0].addEventListener('click', gotoComment)
          console.log("event replaced")
        }, 1000)
        document.getElementsByClassName("power txt-right")[0].innerHTML = "Once powered by Valine"
      }, 1000)
     }
   }
 </script></div><footer><p class="site-info"> 博客已萌萌哒运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span><br> Theme - <a target="_blank" href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With 💗 | Powered by GodBMW & hellflame<br></p></footer><script src="/js/footer.js"></script><script>updateUptime(2016,3,27)</script><div class="back-to-top hidden"><span><i class="iconfont icon-60"></i><span></span> %</span></div><script src="/js/component/back-to-top.js"></script></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script src="/js/mathjax.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.js" async></script><script async src="/js/fancybox.js"></script></body></html>