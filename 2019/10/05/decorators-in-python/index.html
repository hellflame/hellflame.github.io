<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>解析Python中的装饰器 | Hellflame</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="basics,python,"><meta name="description" content="pleased or sad, everything dies with hellflame"><link rel="alternate" href="/atom.xml" title="Hellflame" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="apple-touch-icon" href="/images/favicon.png"><link href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="/icon/iconfont.css"><link rel="stylesheet" href="/css/github-markdown.css"><link rel="stylesheet" href="/css/highlight.css"><script src="/js/util.js"></script><script src="/js/valine.min.js"></script><link href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js" async></script><script src="/js/player.js"></script><link href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script></head><body><div id="app"><div class="header-wrap"><header><div class="site-brand"><div class="site-title"> <a href="/">Hellflame</a></div></div><nav class="site-navigation"><ul class="nav-menu"><li class="nav-item" data-path="/"> <a href="/" target="_self">首页</a></li><li class="nav-item" data-path="/archives/"> <a href="/archives/" target="_self">归档</a></li><li class="nav-item" data-path="/categories/"> <a href="/categories/" target="_self">分类</a></li><li class="nav-item" data-path="/tags/"> <a href="/tags/" target="_self">标签</a></li><li class="nav-item" data-path="/friends/"> <a href="/friends/" target="_self">友链</a></li><li class="nav-item" data-path="/corner-story/"> <a href="/corner-story/" target="_self">转角杀</a></li><li class="nav-item" data-path="/about/"> <a href="/about/" target="_self">关于</a></li><li class="nav-item" data-path="https://github.com/hellflame"> <a href="https://github.com/hellflame" target="_self">Github</a></li></ul></nav><i class="iconfont icon-menu"></i></header></div><script src="/js/navigation.js"></script><div class="container post-index"><div class="post"><div style="position:fixed;right:1em;top:1.5em;cursor:pointer;z-index:999" onclick="toggleTOC()" id="toc"><div style="width:2em;height:2em"><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div></div></div><h1 class="article-title"> <span>解析Python中的装饰器</span></h1><div class="article-top-meta"> <span>发布 : 2019-10-05</span> <span>分类 : <a href="/categories/basics/">basics</a></span> <span>浏览 : <span class="article-timer">--</span></span></div><div class="article-content"><div class="markdown-body"><p>装饰器的作用一般可以概括为复用代码片段。</p><p>即不像 <code>import</code> 复用整个模块，也不像类的继承一样进行系统性的复用和演变，装饰器可以更加灵活的面向代码切片编程。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>如一开始所说，装饰器的本质其实就是闭包，或者说就是函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">  <span class="string">"""不带参数的装饰器"""</span></span><br><span class="line"><span class="meta">  @wraps(func)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">args_wrap</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">"wrap"</span>)</span><br><span class="line">    <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">  <span class="keyword">return</span> args_wrap</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_with_args</span><span class="params">(name)</span>:</span></span><br><span class="line">  <span class="string">"""带参数的装饰器"""</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func_wrap</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">args_wrap</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">      print(<span class="string">"another wrap by &#123;&#125;"</span>.format(name))</span><br><span class="line">      <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> args_wrap</span><br><span class="line">  <span class="keyword">return</span> func_wrap</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(name)</span>:</span></span><br><span class="line">  print(<span class="string">"hello &#123;&#125;"</span>.format(name))</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_with_args("hellflame")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(name)</span>:</span></span><br><span class="line">  print(<span class="string">"hello from &#123;&#125;"</span>.format(name))</span><br></pre></td></tr></table></figure><p>装饰器中最为神秘的可能并不是装饰器本身，而是这个语法糖 <code>@</code> ，这个在装饰过程中起作用的语法(可以说是灵魂存在)。不过它的作用其实很简单，就是 <code>执行函数</code> + <code>赋值</code>。大概效果如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(name)</span>:</span></span><br><span class="line">  print(<span class="string">"hello &#123;&#125;"</span>.format(name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ====== equals =======</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(name)</span>:</span></span><br><span class="line">  print(<span class="string">"hello &#123;&#125;"</span>.format(name))</span><br><span class="line"></span><br><span class="line">x = decorator(x)</span><br></pre></td></tr></table></figure><p>对于带参数的装饰器:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator_with_args("hellflame")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(name)</span>:</span></span><br><span class="line">  print(<span class="string">"hello from &#123;&#125;"</span>.format(name))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ======= equals =======</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(name)</span>:</span></span><br><span class="line">  print(<span class="string">"hello from &#123;&#125;"</span>.format(name))</span><br><span class="line"></span><br><span class="line">y = decorator_with_args(<span class="string">"hellflame"</span>)(y)</span><br></pre></td></tr></table></figure><p>就这个语法糖 <code>@</code> 符号的使用要求其实很简单，即使不是一个装饰器，依然可以使用该符号，比如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(func)</span>:</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">"&#123;&#125;, you are trapped"</span>.format(func.__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@say</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">well</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在装饰阶段，<code>well, you are trapped</code> 便会跃然纸上，如果进一步执行 <code>well</code> ，便会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">well()  <span class="comment"># 'NoneType' object is not callable</span></span><br></pre></td></tr></table></figure><p><code>well</code> 之所以变成了 <code>None</code> ，其实是因为 <code>say</code> 默认返回值为 <code>None</code>。如果换一种写法，可能更能明白现状:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(func)</span>:</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">"Hi, &#123;&#125;"</span>.format(func.__name__)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">lambda</span>: <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@say</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">well</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">well()  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>此时 <code>well</code> 其实是 <code>lambda: 1</code>。也就是说，其实装饰器的写法并不重要，重要的是返回一个 <code>可执行对象</code>，甚至是说一个可以加一对 <code>()</code> 然后运行的东西，所以还有可能出现下面神奇的东西</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span><span class="params">(func)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> type(<span class="string">"OK"</span>, (object,), &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@say</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">well</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">well()  <span class="comment"># 没错，这是一个 `OK` 类的实例 </span></span><br><span class="line">print(well().__class__.__name__)  <span class="comment"># 甚至可以确认一下名字</span></span><br></pre></td></tr></table></figure><p>不知道这算不算python中 <code>duck typing</code></p><p>如果知道了装饰过程是如何进行的，讲真就不用那么在意装饰器本身的书写模式了，而且也就可以更加灵活的使用语法糖了。不过说了装饰过程，装饰器本身其实还是有很多需要注意的地方:</p><h4 id="1-元信息丢失"><a href="#1-元信息丢失" class="headerlink" title="1. 元信息丢失"></a>1. 元信息丢失</h4><p>由于装饰过程其实是一个赋值过程，那么最后得到的被装饰对象其实是装饰器返回出来的可执行对象。这一套狸猫换太子，一般会损失 <code>__module__, __name__, __doc__</code> 这些元信息，大多数情况下其实都不是很重要，在调试环节和纠错时会比较有用。<code>functools</code> 中的 <code>wraps</code> 装饰器恰好是用来恢复这些元信息的。不过需要注意的是，<code>class</code> 也可以被 <code>wraps</code> 恢复元信息，即:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">issubclass(A(), A)  <span class="comment">#  issubclass() arg 1 must be a class</span></span><br></pre></td></tr></table></figure><p>语法和 <code>A</code> 的实例都不存在问题，问题在于 <code>A</code> 本身已经不再是 <code>class</code> ，而是一个方法，也就是说不管再怎么恢复，<code>A类</code> 已经不是 <code>A类</code> 了，而是 <code>A 方法</code> 。</p><h4 id="2-返回函数"><a href="#2-返回函数" class="headerlink" title="2. 返回函数"></a>2. 返回函数</h4><p>如上所述，不管原来是什么，被装饰之后的对象变成了一个函数，即使装饰器和被装饰对象都是类也不行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrap</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">      print(<span class="string">"Wrap"</span>)</span><br><span class="line">      <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@Wrap()</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gift</span><span class="params">(object)</span>:</span></span><br><span class="line">  Impossible = <span class="string">"really?"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"surprise"</span>)</span><br><span class="line">    self.content = <span class="string">"nothing"</span></span><br><span class="line"></span><br><span class="line">print(Gift().content)  <span class="comment"># nothing</span></span><br><span class="line">type(Gift)  <span class="comment"># function</span></span><br><span class="line">Gift.Impossible  <span class="comment"># 'function' object has no attribute 'Impossible'</span></span><br><span class="line">Gift().Impossible  <span class="comment"># really?</span></span><br></pre></td></tr></table></figure><h4 id="3-执行阶段"><a href="#3-执行阶段" class="headerlink" title="3. 执行阶段"></a>3. 执行阶段</h4><p>在装饰器中，由于语法糖 <code>@</code> 会执行装饰器，所以第一层函数一定会被执行。可以说 <code>参数修饰函数</code> (涉及到被装饰对象执行时上下文处理的函数，也就是 <code>args_wrap</code> 类似的函数) 才是在被装饰对象执行时真正执行的对象，在其外层的代码都会在装饰阶段就执行完毕。</p><p>这里的区别在于</p><ol><li>装饰阶段在全局作用域执行，一般不会有竞争条件，而 <code>参数修饰函数</code> 却是在每次执行被装饰对象时都会运行，竞争条件与被装饰对象一致。也就是说如果在多线程环境下使用被装饰对象，那么可以通过 <code>参数装饰函数</code> 控制并发条件</li><li><code>参数修饰函数</code> 相对装饰器中的其他部分而言，使用的是内部作用域，不能对外部作用域直接进行赋值操作。这和闭包的使用是一致的</li></ol><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>装饰器的用途可以说是很广了。</p><p>从控制被装饰对象的 <code>输入</code>、<code>执行</code> 和 <code>输出</code> 来分的话，有如下例子：</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>比如通过装饰器传入额外参数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysql_context</span><span class="params">(connection_config=DEFAULT_MYSQL_CONFIG)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func_wrap</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">args_wrap</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">      <span class="keyword">with</span> closing(mysql.connection(**connection_config)) <span class="keyword">as</span> cursor:</span><br><span class="line">      	<span class="keyword">return</span> func(cursor=cursor, *args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> args_wrap</span><br><span class="line">  <span class="keyword">return</span> func_wrap</span><br><span class="line"></span><br><span class="line"><span class="meta">@mysql_context()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_data</span><span class="params">(cursor)</span>:</span></span><br><span class="line">  <span class="comment"># do things with cursor</span></span><br></pre></td></tr></table></figure><p>以上是一个通过装饰器将额外的 <code>cursor</code> 传入被装饰函数的例子，并且能够进行自动上下文管理 (通过上下文管理器)。当然一般不推荐修改被装饰函数的函数签名</p><h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p>干预被装饰对象的执行过程有很多种例子，记忆中比较多的用法包括:</p><ol><li>单例模式的实例管理</li><li>权限验证 (根据权限信息选择执行被装饰函数还是执行无权限响应)</li><li>函数计时器 (记录函数运行时间)</li></ol><p>例子比较多，其中单例模式的应用应该有另外的文章记录，其它应用应该比较直白</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>这种用法比较少见，但是在少数需要进行消息分发的场景下，用装饰器可以很方便</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dispatch</span><span class="params">(targets)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func_wrap</span><span class="params">(func)</span>:</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">args_wrap</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">      result = func(*args, **kwargs)</span><br><span class="line">      <span class="keyword">for</span> target <span class="keyword">in</span> targets:</span><br><span class="line">        send_message(target, result)</span><br><span class="line">    	<span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> args_wrap</span><br><span class="line">  <span class="keyword">return</span> func_wrap</span><br><span class="line"></span><br><span class="line"><span class="meta">@dispatch(["root", "apt", "docker"])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">warning</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"warning"</span></span><br></pre></td></tr></table></figure><p>以及一种对于上述三者都不怎么重视的应用</p><h4 id="钩子注册"><a href="#钩子注册" class="headerlink" title="钩子注册"></a>钩子注册</h4><blockquote><p>即对于被装饰对象的返回值不再重视，而是需要被程序其他部分知道被注册的对象即可</p></blockquote><p>比如个人比较常用的一个例子就是路由注册</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ROUTER = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">router</span><span class="params">(path_patterns)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(handler)</span>:</span></span><br><span class="line">    _ROUTER.append((path_patterns, handler))</span><br><span class="line">  <span class="keyword">return</span> register</span><br><span class="line"></span><br><span class="line"><span class="meta">@router("/(index|error)")</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntryHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, page)</span>:</span></span><br><span class="line">    self.write(page)</span><br></pre></td></tr></table></figure><p>这里大概是在 <code>tornado</code> 中利用 <code>router</code> 函数进行路由的注册，代码思路应该在 <a href="https://github.com/hellflame/webpack-tornado" target="_blank" rel="noopener">这个项目</a> 里有具体体现。这里对于类的返回值(实例)已经不再需要，所以直接在装饰器中舍弃了返回值</p><p>另一个知道的例子如 <a href="https://github.com/pallets/click" target="_blank" rel="noopener">click</a> ，一个终端命令行解析工具</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>装饰器的出现，尤其是语法糖的使用，让python中的非侵入式开发变得十分方便，也让代码的复用级别进一步降低，也是 <code>函数式编程</code> 发展过程中出现的必然产物。</p><p>装饰器如果使用得当将会事半功倍，过度滥用也会导致头重脚轻。从整体项目来看，装饰器将python作为胶水语言的特点进一步突出，但是谁都知道，不可能整个项目都是胶水，在大型项目中，胶水更不应该出现太频繁，否则将会导致项目各模型之间穿孔严重，耦合加剧，甚者都会变成一锅浆糊。</p><p>重要的是，在合适的地方使用合适的工具</p></div></div><div class="copy-right"><div class="markdown-body"><blockquote> 本文作者 : hellflame<br> 原文链接 : <a href="">https://hellflame.github.io/2019/10/05/decorators-in-python/</a><br> 版权声明 : 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</blockquote></div></div><div class="social-share" style="margin-top:-2rem" data-wechat-qrcode-title="<p>微信扫一扫</p>" data-wechat-qrcode-helper="<p>微信右上角, 扫一扫分享</p>" data-sites="qzone, qq, weibo, facebook, twitter"> <span style="color:#6b7487;font-size:1.4rem">分享到:</span></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js" async></script><div class="article-footer"><div class="article-meta pull-left"><span><i class="iconfont icon-06tags"></i> 标签: <span class="span--tag"><a href="/tags/python/">#python</a></span></span></div><div class="article-meta pull-right"></div></div></div><aside id="sidebar"><p id="sidebar-header"></p><ol id="sidebar-toc"></ol></aside><script async>getTOC().length||$("#toc").remove()</script><nav class="post-navigation"><div class="nav-pre"><i class="iconfont icon-prev"></i> 上一篇: <a href="/2019/10/04/singleton-in-python/" target="_self">解析Python中的单例</a></div><div class="nav-next"> 下一篇: <a href="/2019/11/30/data-center-by-kafka/" target="_self">基于Kafka搭建数据分发中心</a><i class="iconfont icon-next"></i></div></nav><a href="#comment" class="comment-anchor"></a><div class="comment-title"><i class="iconfont icon-footprint"></i> 留下足迹<i class="iconfont icon-footprint"></i></div> <a style="margin-bottom:1em;display:block;cursor:pointer" onclick="gotoComment()">通过issue留言</a><div id="vcomments"></div><script defer="defer">new Valine({el:"#vcomments",appId:"a",appKey:"b",notify:!1,verify:!1,avatar:"robohash",placeholder:"不填邮箱，网址, 也能收到回复哦♪(^∇^*)\n当然也不一定会回复-_-",path:getRealPath()})</script><script defer="defer">
   function gotoComment() {
    location.href = `https://github.com/hellflame/hellflame.github.io/issues/new?title=关于%0A“%E8%A7%A3%E6%9E%90Python%E4%B8%AD%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8”&body=%23%23%23%20[原文地址](https://hellflame.github.io/2019/10/05/decorators-in-python/)%0A%0A%23%23%23%20想说的话(问题/支持/异议)%20%20%0A%0A${document.getElementById('veditor').value}`
   }
   document.onreadystatechange = (e) => {
     if(document.readyState === 'complete') {
      setTimeout(() => {
        const target = document.getElementsByClassName("vsubmit vbtn")[0]
        target.outerHTML = target.outerHTML
        setTimeout(() => {
          document.getElementsByClassName("vsubmit vbtn")[0].addEventListener('click', gotoComment)
          console.log("event replaced")
        }, 1000)
        document.getElementsByClassName("power txt-right")[0].innerHTML = "Once powered by Valine"
      }, 1000)
     }
   }
 </script></div><footer><p class="site-info"> 博客已萌萌哒运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span><br> Theme - <a target="_blank" href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With 💗 | Powered by GodBMW & hellflame<br></p></footer><script src="/js/footer.js"></script><script>updateUptime(2016,3,27)</script><div class="back-to-top hidden"><span><i class="iconfont icon-60"></i><span></span> %</span></div><script src="/js/component/back-to-top.js"></script></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script src="/js/mathjax.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.js" async></script><script async src="/js/fancybox.js"></script></body></html>