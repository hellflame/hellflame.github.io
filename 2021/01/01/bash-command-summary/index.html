<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>bash常用命令集锦 | Hellflame</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="basics,linux,"><meta name="description" content="pleased or sad, everything dies with hellflame"><link rel="alternate" href="/atom.xml" title="Hellflame" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="apple-touch-icon" href="/images/favicon.png"><link href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="/icon/iconfont.css"><link rel="stylesheet" href="/css/github-markdown.css"><link rel="stylesheet" href="/css/highlight.css"><script src="/js/util.js"></script><script src="/js/valine.min.js"></script><link href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js" async></script><script src="/js/player.js"></script><link href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script></head><body><div id="app"><div class="header-wrap"><header><div class="site-brand"><div class="site-title"> <a href="/">Hellflame</a></div></div><nav class="site-navigation"><ul class="nav-menu"><li class="nav-item" data-path="/"> <a href="/" target="_self">首页</a></li><li class="nav-item" data-path="/archives/"> <a href="/archives/" target="_self">归档</a></li><li class="nav-item" data-path="/categories/"> <a href="/categories/" target="_self">分类</a></li><li class="nav-item" data-path="/tags/"> <a href="/tags/" target="_self">标签</a></li><li class="nav-item" data-path="/friends/"> <a href="/friends/" target="_self">友链</a></li><li class="nav-item" data-path="/corner-story/"> <a href="/corner-story/" target="_self">转角杀</a></li><li class="nav-item" data-path="/about/"> <a href="/about/" target="_self">关于</a></li><li class="nav-item" data-path="https://github.com/hellflame"> <a href="https://github.com/hellflame" target="_self">Github</a></li></ul></nav><i class="iconfont icon-menu"></i></header></div><script src="/js/navigation.js"></script><div class="container post-index"><div class="post"><div style="position:fixed;right:1em;top:1.5em;cursor:pointer;z-index:999" onclick="toggleTOC()" id="toc"><div style="width:2em;height:2em"><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div></div></div><h1 class="article-title"> <span>bash常用命令集锦</span></h1><div class="article-top-meta"> <span>发布 : 2021-01-01</span> <span>分类 : <a href="/categories/basics/">basics</a></span> <span>浏览 : <span class="article-timer">--</span></span></div><div class="article-content"><div class="markdown-body"><p>以下主要用 <code>bash</code> 作为终端实例</p><h3 id="一-shell-配置"><a href="#一-shell-配置" class="headerlink" title="一. shell 配置"></a>一. shell 配置</h3><h4 id="1-输入提示-prompt"><a href="#1-输入提示-prompt" class="headerlink" title="1. 输入提示 (prompt)"></a>1. 输入提示 (prompt)</h4><p>指的是在未输入任何命令时在终端开头的提示，可以展示当前的用户、时间、当前工作目录，甚至 <code>git</code> 状态。每执行完一个命令或函数之后会更新提示</p><p>输入提示由 bash 的环境变量 <code>PS1</code> 决定，最简单的修改方式如：</p><p><code>PS1=&#39;[\t] \W &#39;</code></p><p>提示就会变成类似这样</p><p><code>[10:52:12] ~</code></p><p>还有更高端的<a href="https://github.com/twolfson/sexy-bash-prompt" target="_blank" rel="noopener">github上的配置</a>，自己的配置就是基于这个版本的修改版</p><h4 id="2-命令自动补全"><a href="#2-命令自动补全" class="headerlink" title="2. 命令自动补全"></a>2. 命令自动补全</h4><p>随着系统的使用时间越来越长，免不了会装各种命令程序，最终可能会有成千上万的可执行命令，如果不是常用命令，很难一次就输入正确，虽然也比较浪费时间，所以一个命令补全显得十分有必要</p><p>大多数linux的发行版本里都会有最基本的命令补全，当在命令行输入 <code>ls</code> 时，按下两次 <code>tab</code> ，应该会得到以下输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">ls         lsappinfo  lsbom      lskq       lsm        lsmp       lsof       lsvfs</span><br></pre></td></tr></table></figure><p>会在下一行开始，显示出所有以 <code>ls</code> 开头的命令</p><p>当输入的长度对应的可选命令只有一个候选时，按下一次 <code>tab</code> 即可完全补全命令，如果侯选命令都有比输入更长的相同开头，一次 <code>tab</code> 会补全到那个更长的开头</p><p>比如候选命令包括</p><p><code>abc abd abe</code></p><p>那么输入 <code>a</code> 后一次 <code>tab</code> 即可补全到 <code>ab</code></p><p>当然还有命令级别的自动补全，比如 <code>apt</code> , <code>npm</code> , <code>pip</code> 这些命令都是提供了参数级别的自动补全，不过需要配置就是了，比如需要安装 <code>bash-completion</code>，然后将对应的补全脚本放在合适的地方，补全脚本可能是原本在安装软件的时候提供的，程序自己也可以提供这样的补全脚本，提示用户放在正确的位置。</p><p>比如执行 <code>npm completion</code> ，会输出补全脚本，其中注释里会提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># npm command completion script</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Installation: npm completion &gt;&gt; ~/.bashrc  (or ~/.zshrc)</span></span><br><span class="line"><span class="comment"># Or, maybe: npm completion &gt; /usr/local/etc/bash_completion.d/npm</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><p>这些补全脚本可以极大的提高命令使用的舒适度</p><blockquote><p>自动补全大小写忽略</p></blockquote><p>如果有时候命令或者参数里包含大写的字符，可能输入会麻烦一点，所以可以进一步偷懒</p><p>执行 <code>echo &#39;set completion-ignore-case on&#39; &gt;&gt; ~/.inputrc</code> 即可，在下一次开启bash实例的时候就会生效，多用在自动匹配文件名上</p><h4 id="3-bash启动提示"><a href="#3-bash启动提示" class="headerlink" title="3. bash启动提示"></a>3. bash启动提示</h4><p>即在每次开启bash时输出的提示，类似这样:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> _______________________________________</span><br><span class="line">/ Martin was probably ripping them off. \</span><br><span class="line">| That<span class="string">'s some family, isn'</span>t it? Incest, |</span><br><span class="line">| prostitution, fanaticism, software.   |</span><br><span class="line">|                                       |</span><br><span class="line">\ -- Charles Willeford, <span class="string">"Miami Blues"</span>   /</span><br><span class="line"> ---------------------------------------</span><br><span class="line">  \                                  ,+*^^*+___+++_</span><br><span class="line">   \                           ,*^^^^              )</span><br><span class="line">    \                       _+*                     ^**+_</span><br><span class="line">     \                    +^       _ _++*+_+++_,         )</span><br><span class="line">              _+^^*+_    (     ,+*^ ^          \+_        )</span><br><span class="line">             &#123;       )  (    ,(    ,_+--+--,      ^)      ^\</span><br><span class="line">            &#123; (@)    &#125; f   ,(  ,+-^ __*_*_  ^^\_   ^\       )</span><br><span class="line">           &#123;:;-/    (_+*-+^^^^^+*+*&lt;_ _++_)_    )    )      /</span><br><span class="line">          ( /  (    (        ,___    ^*+_+* )   &lt;    &lt;      \</span><br><span class="line">           U _/     )    *--&lt;  ) ^\-----++__)   )    )       )</span><br><span class="line">            (      )  _(^)^^))  )  )\^^^^^))^*+/    /       /</span><br><span class="line">          (      /  (_))_^)) )  )  ))^^^^^))^^^)__/     +^^</span><br><span class="line">         (     ,/    (^))^))  )  ) ))^^^^^^^))^^)       _)</span><br><span class="line">          *+__+*       (_))^)  ) ) ))^^^^^^))^^^^^)____*^</span><br><span class="line">          \             \_)^)_)) ))^^^^^^^^^^))^^^^)</span><br><span class="line">           (_             ^\__^^^^^^^^^^^^))^^^^^^^)</span><br><span class="line">             ^\___            ^\__^^^^^^))^^^^^^^^)\\</span><br><span class="line">                  ^^^^^\uuu/^^\uuu/^^^^\^\^\^\^\^\^\^\</span><br><span class="line">                     ___) &gt;____) &gt;___   ^\_\_\_\_\_\_\)</span><br><span class="line">                    ^^^//\\_^^//\\_^       ^(\_\_\_\)</span><br><span class="line">                      ^^^ ^^ ^^^ ^</span><br></pre></td></tr></table></figure><p>精心设计的字符画，加上一段名言，也可以五彩缤纷的</p><p>基本原理就是在每次bash开始时，会按顺序导入一堆配置文件，执行命令或者修改环境变量等等</p><p>这里可以修改和用户最近的配置文件 <code>$HOME/.bashrc</code> ，这里能发现很多重要的配置，很多地方都会用到</p><p>个人配置如下(命令大概需要额外安装)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cows=(beavis.zen blowfish bong bud-frogs bunny cheese cower daemon default dragon-and-cow dragon elephant-in-snake elephant eyes flaming-sheep ghostbusters hellokitty kiss kitty koala kosh luke-koala meow milk moofasa moose mutilated ren satanic sheep skeleton small stegosaurus stimpy supermilker surgery three-eyes turkey turtle tux udder vader-koala vader www)</span><br><span class="line">cow=<span class="variable">$&#123;cows[$(($RANDOM % $&#123;#cows[@]&#125;</span>))]&#125;</span><br><span class="line">fortune -s computers | cowsay -f <span class="variable">$cow</span> | lolcat</span><br></pre></td></tr></table></figure><p>大概输出过程包括随机选择字符画模板，输出名言，字符画，彩虹输出</p><h4 id="4-命令快捷方式"><a href="#4-命令快捷方式" class="headerlink" title="4. 命令快捷方式"></a>4. 命令快捷方式</h4><p>核心就是 <code>alias</code> 函数</p><p>大多数能看到的最多的使用场景，应该是 <code>ls</code> 命令</p><p>比如实际执行 <code>ls</code> 的时候，会出现彩色的输出</p><p>可以在 <code>$HOME/.bashrc</code> 里看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> ls=<span class="string">'ls --color=auto'</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">'ls'</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">'ls -l'</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">'ls -a'</span></span><br></pre></td></tr></table></figure><p>意思就是在执行 <code>ls</code> 时，其实自带里一个参数 <code>--color=auto</code></p><p>在执行 <code>ll</code> 的时候，其实执行的是 <code>ls -l</code></p><p>自己比较常用的方式还包括</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> blogs=<span class="string">'ssh blogserver'</span>  <span class="comment"># ssh到blogserver时，仅需要执行 blogs 即可 (当然，这需要ssh配置正确)</span></span><br><span class="line"><span class="built_in">alias</span> mysqlMaster=<span class="string">'mysql -hxxx.xxx -uxxx -pxxx -A'</span>  <span class="comment"># mysql登陆到服务器时，只需要执行 mysqlMaster 即可，风险在于密码明文化了</span></span><br></pre></td></tr></table></figure><p>如果想要跳过快捷方式，直接执行命令，比如 <code>ls</code> ，那么用完整的命令路径即可，如 <code>/bin/ls</code> ，可以通过 <code>which ls</code> 找到 <code>ls</code> 的完整命令路径</p><h3 id="二-常用命令"><a href="#二-常用命令" class="headerlink" title="二. 常用命令"></a>二. 常用命令</h3><h4 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h4><h5 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h5><p>当之无愧最常用的命令，列出当前或指定路径的文件信息，除了最基本的 <code>ls</code> 无参数执行外，还有 <code>ls -l</code> 等</p><p>有一个不常用，但是曾经解救人于危难的参数 <code>ls -li</code></p><p>输出如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ls -li</span><br><span class="line">total 8</span><br><span class="line">4325380 -rwxr-xr-x 1 root root 527 Nov 17 10:21 a.sh</span><br><span class="line">4325379 -rwxr-xr-x 1 root root 530 Nov 17 10:16 b.sh</span><br></pre></td></tr></table></figure><p>第一列输出了文件的 inode 号，是某个文件在一个分区上的唯一索引号，如果两个文件的索引号一致，那肯定是同一个文件。当一个文件的文件名不能在终端上显示为参数时，这个索引号就很重要了</p><p>比如要删除一个特殊文件名的文件 <code>-</code> 或者乱码的文件 (在终端里用unrar解压一个Windows环境下压缩的rar文件)</p><p>首选需要找到要删除文件的inode号，然后用 <code>find</code> 执行删除 <code>find . -inum {inode} -delete</code> 或者删除目录 <code>find . -inum {inode} -exec rm -rf {} +</code></p><blockquote><p>控制 ls 染色</p></blockquote><p>通过环境变量 <code>LS_COLORS</code> ，写在 <code>.bashrc</code> 即可</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LS_COLORS=<span class="string">"*.yml=01;35:<span class="variable">$LS_COLORS</span>"</span></span><br></pre></td></tr></table></figure><p>将 <code>*.yml</code> 染为紫色</p><h5 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h5><p>全称应该叫 <code>link</code> ，用于生成链接，一般是硬连接或者软连接</p><p>软连接是创建一个文件，并指向目标文件(linux中一切皆文件)，目的是创建一个文件的快捷方式，删除之后，只是把快捷方式删除而已，不影响目标文件</p><p>通过 <code>ln -s</code> 创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo fine &gt; linux</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">linux</span><br><span class="line"><span class="comment"># ln -s linux l</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">l  linux</span><br><span class="line"><span class="comment"># ls -li</span></span><br><span class="line">total 4</span><br><span class="line">917674 lrwxrwxrwx 1 root root 5 Jan  1 13:09 l -&gt; linux</span><br><span class="line">917673 -rw-r--r-- 1 root root 5 Jan  1 13:09 linux</span><br></pre></td></tr></table></figure><p>硬连接让一个文件拥有多个可用路径，可以用于备份，防止误删除等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ln linux h</span></span><br><span class="line"><span class="comment"># ls -li</span></span><br><span class="line">total 8</span><br><span class="line">917673 -rw-r--r-- 2 root root 5 Jan  1 13:09 h</span><br><span class="line">917673 -rw-r--r-- 2 root root 5 Jan  1 13:09 linux</span><br><span class="line">917674 lrwxrwxrwx 1 root root 5 Jan  1 13:09 l -&gt; linux</span><br></pre></td></tr></table></figure><p>创建硬连接比软连接更简单，没有 <code>-s</code> 参数，创建的硬连接和源文件指向同一个文件，可以看到两者 inode 索引相同，和软连接不一样，本身也并没有导致磁盘空间占用的翻倍。</p><p>软硬连接对比:</p><ol><li>软连接创建了新的文件，硬连接并没有</li><li>软连接可以连接到文件系统内任何地方，硬连接限制在当前设备，否则会报错 <code>Invalid cross-device link</code>，这和文件系统有关</li><li>硬连接会增加文件索引数，如上面展示的 <code>ls -li</code> 结果中的第三列，由原本的 1 增长为 2，表示该文件的硬连接数为 2，软连接不会增加该指数</li></ol><blockquote><p>特别点：一个目录的硬连接数 = 子文件数 + 2</p></blockquote><p>一个目录的每个子文件都会有一个硬连接叫 <code>..</code> 指向父路径，所以是 <code>子文件数</code> ，该目录自身是一个文件，所以硬连接数 <code>+1</code> ，然后该目录里还有一个 <code>.</code> 指向当前路径，所以硬连接数 <code>+1</code></p><h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h5><p>万能删除 <code>rm -rf xxx</code> ，除了 <code>/</code> 大概都能通通删掉</p><h5 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h5><p><code>change directory</code> 切换当前路径</p><p>默认动作:</p><p><code>cd</code> 回到用户 home 目录</p><p><code>cd -</code> 回到前一个目录</p><h5 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h5><p>创建目录</p><p><code>mkdir -p a/b/c/d</code> 一路创建目录到 <code>a</code></p><h5 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h5><p>端口资源查看，如查看某端口被那个进程占用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># lsof -i :80</span></span><br><span class="line">COMMAND   PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">nginx    7775   root   10u  IPv4 932993      0t0  TCP *:http (LISTEN)</span><br><span class="line">nginx   30628 nobody   10u  IPv4 932993      0t0  TCP *:http (LISTEN)</span><br><span class="line">nginx   30629 nobody   10u  IPv4 932993      0t0  TCP *:http (LISTEN)</span><br></pre></td></tr></table></figure><h5 id="df"><a href="#df" class="headerlink" title="df"></a>df</h5><p>展示硬盘占用情况</p><h5 id="du"><a href="#du" class="headerlink" title="du"></a>du</h5><p>展示给定路径的资源占用</p><p>组合命令: <code>du -hc . | tail -n 1</code> 获取当前目录总大小</p><h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><p>搜索文件</p><p>按照文件名搜索: <code>find . -name \*.py</code> 搜索当前路径下所有 .py 文件</p><p>按照文件类型搜索: <code>find . -type d</code> 搜索当前路径下所有目录类型</p><h5 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h5><p>按照树形结构展示目标路径:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tree x</span></span><br><span class="line">x</span><br><span class="line">├── h</span><br><span class="line">├── l -&gt; linux</span><br><span class="line">└── linux</span><br></pre></td></tr></table></figure><h5 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h5><p>查看端口占用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -ntpl</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:26381           0.0.0.0:*               LISTEN      16693/redis-sentine</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      7775/nginx: master</span><br></pre></td></tr></table></figure><p>常用组合 <code>netstat -ntpl</code></p><h4 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h4><h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h5><p>进程列表</p><p>常用组合 <code>ps -ef | grep xxx</code>: 搜索给定进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br><span class="line">root      7775     1  0  2020 ?        00:00:00 nginx: master process nginx</span><br><span class="line">root     27452 23960  0 13:55 pts/1    00:00:00 grep nginx</span><br><span class="line">nobody   30628  7775  0  2020 ?        00:00:31 nginx: worker process</span><br><span class="line">nobody   30629  7775  0  2020 ?        00:00:00 nginx: worker process</span><br></pre></td></tr></table></figure><p>各列分别表示：用户，进程号，父进程号，class，进程开始时间，TTY，CPU时间，命令</p><h5 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h5><p>给指定进程发送信号，不仅仅是 <code>SIGKILL</code></p><p>一般先通过 <code>ps</code> 找到目标进程id，<code>kill -9 {pid}</code></p><h5 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h5><p>动态展示系统进程状态 (比 top 直观)</p><h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><h5 id="文本处理程序"><a href="#文本处理程序" class="headerlink" title="文本处理程序"></a>文本处理程序</h5><p>如：awk, grep, tail, head, less, more, cat, sort</p><p>每个命令都很少单独使用，大多数时候都是组合在一起</p><p>例子:</p><ul><li>docker同时持续查看多个容器日志的关键词</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps | grep xxx | awk <span class="string">'&#123;print $1&#125;'</span> | xargs docker inspect --format &#123;&#123;.LogPath&#125;&#125; | xargs tail -f | grep keyword</span><br></pre></td></tr></table></figure><h5 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h5><p>通过ssh协议访问目标机器</p><p><strong>首先生成ssh 公钥密钥对</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ssh-keygen -t ecdsa -C hellflame</span></span><br><span class="line">Generating public/private ecdsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_ecdsa): key</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> key.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> key.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:c1a7ZLBJEHNA7Q5oZ3Ud9lMQ7rcm4yaHNpsdIxc2uyA hellflame</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[ECDSA 256]---+</span></span><br><span class="line"><span class="string">|       .*+.  .=+.|</span></span><br><span class="line"><span class="string">|         +o .o...|</span></span><br><span class="line"><span class="string">|       . oo.. ...|</span></span><br><span class="line"><span class="string">|      o +..= o  .|</span></span><br><span class="line"><span class="string">|     . oSo= ++. .|</span></span><br><span class="line"><span class="string">|         +.o..+..|</span></span><br><span class="line"><span class="string">|         E ooB o |</span></span><br><span class="line"><span class="string">|          .=BoB  |</span></span><br><span class="line"><span class="string">|          .o*+   |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br><span class="line"><span class="string"># ls</span></span><br><span class="line"><span class="string">key  key.pub</span></span><br></pre></td></tr></table></figure><p><strong>然后在服务端部署公钥</strong></p><p>将 <code>key.pub</code> 里的内容写进服务端 <code>$HOME/.ssh/authorized_keys</code>，如果没有这个文件，创建之后，文件权限需要限制只允许当前用户有读权限</p><p>一般为了安全，在服务端可设置仅允许通过 ssh key 登陆，在 <code>/etc/ssh/sshd_config</code> 配置 <code>PasswordAuthentication no</code> ，拒绝密码登陆</p><p>更新之后重启sshd即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><p><strong>配置本地ssh公钥</strong></p><p>在当前客户端，<code>$HOME/.ssh/config</code> 文件中添加配置如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host xxx.xx.xx.x</span><br><span class="line">    IdentityFile /path/to/key</span><br><span class="line">    User root  <span class="comment"># 服务器登陆用户名</span></span><br><span class="line">    ServerAliveInterval 30</span><br><span class="line">    ServerAliveCountMax 3</span><br></pre></td></tr></table></figure><p>其中 <code>/path/to/key</code> 指向刚生成的密钥路径</p></div></div><div class="copy-right"><div class="markdown-body"><blockquote> 本文作者 : hellflame<br> 原文链接 : <a href="">https://hellflame.github.io/2021/01/01/bash-command-summary/</a><br> 版权声明 : 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</blockquote></div></div><div class="social-share" style="margin-top:-2rem" data-wechat-qrcode-title="<p>微信扫一扫</p>" data-wechat-qrcode-helper="<p>微信右上角, 扫一扫分享</p>" data-sites="qzone, qq, weibo, facebook, twitter"> <span style="color:#6b7487;font-size:1.4rem">分享到:</span></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js" async></script><div class="article-footer"><div class="article-meta pull-left"><span><i class="iconfont icon-06tags"></i> 标签: <span class="span--tag"><a href="/tags/linux/">#linux</a></span></span></div><div class="article-meta pull-right"></div></div></div><aside id="sidebar"><p id="sidebar-header"></p><ol id="sidebar-toc"></ol></aside><script async>getTOC().length||$("#toc").remove()</script><nav class="post-navigation"><div class="nav-pre"><i class="iconfont icon-prev"></i> 上一篇: <a href="/2020/11/16/jinjiang-park/" target="_self">锦江乐园</a></div></nav><a href="#comment" class="comment-anchor"></a><div class="comment-title"><i class="iconfont icon-footprint"></i> 留下足迹<i class="iconfont icon-footprint"></i></div> <a style="margin-bottom:1em;display:block;cursor:pointer" onclick="gotoComment()">通过issue留言</a><div id="vcomments"></div><script defer="defer">new Valine({el:"#vcomments",appId:"a",appKey:"b",notify:!1,verify:!1,avatar:"robohash",placeholder:"不填邮箱，网址, 也能收到回复哦♪(^∇^*)\n当然也不一定会回复-_-",path:getRealPath()})</script><script defer="defer">
   function gotoComment() {
    location.href = `https://github.com/hellflame/hellflame.github.io/issues/new?title=关于%0A“bash%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6”&body=%23%23%23%20[原文地址](https://hellflame.github.io/2021/01/01/bash-command-summary/)%0A%0A%23%23%23%20想说的话(问题/支持/异议)%20%20%0A%0A${document.getElementById('veditor').value}`
   }
   document.onreadystatechange = (e) => {
     if(document.readyState === 'complete') {
      setTimeout(() => {
        const target = document.getElementsByClassName("vsubmit vbtn")[0]
        target.outerHTML = target.outerHTML
        setTimeout(() => {
          document.getElementsByClassName("vsubmit vbtn")[0].addEventListener('click', gotoComment)
          console.log("event replaced")
        }, 1000)
        document.getElementsByClassName("power txt-right")[0].innerHTML = "Once powered by Valine"
      }, 1000)
     }
   }
 </script></div><footer><p class="site-info"> 博客已萌萌哒运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span><br> Theme - <a target="_blank" href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With 💗 | Powered by GodBMW & hellflame<br></p></footer><script src="/js/footer.js"></script><script>updateUptime(2016,3,27)</script><div class="back-to-top hidden"><span><i class="iconfont icon-60"></i><span></span> %</span></div><script src="/js/component/back-to-top.js"></script></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script src="/js/mathjax.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.js" async></script><script async src="/js/fancybox.js"></script></body></html>