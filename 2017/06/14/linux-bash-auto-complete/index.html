<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>10种有用的Linux bash自动补全实例 | Hellflame</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="translations,python,linux,"><meta name="description" content="pleased or sad, everything dies with hellflame"><link rel="alternate" href="/atom.xml" title="Hellflame" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="apple-touch-icon" href="/images/favicon.png"><link href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="/icon/iconfont.css"><link rel="stylesheet" href="/css/github-markdown.css"><link rel="stylesheet" href="/css/highlight.css"><script src="/js/util.js"></script><script src="/js/valine.min.js"></script><link href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js" async></script><script src="/js/player.js"></script><link href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script></head><body><div id="app"><div class="header-wrap"><header><div class="site-brand"><div class="site-title"> <a href="/">Hellflame</a></div></div><nav class="site-navigation"><ul class="nav-menu"><li class="nav-item" data-path="/"> <a href="/" target="_self">首页</a></li><li class="nav-item" data-path="/archives/"> <a href="/archives/" target="_self">归档</a></li><li class="nav-item" data-path="/categories/"> <a href="/categories/" target="_self">分类</a></li><li class="nav-item" data-path="/tags/"> <a href="/tags/" target="_self">标签</a></li><li class="nav-item" data-path="/friends/"> <a href="/friends/" target="_self">友链</a></li><li class="nav-item" data-path="/corner-story/"> <a href="/corner-story/" target="_self">转角杀</a></li><li class="nav-item" data-path="/about/"> <a href="/about/" target="_self">关于</a></li><li class="nav-item" data-path="https://github.com/hellflame"> <a href="https://github.com/hellflame" target="_self">Github</a></li></ul></nav><i class="iconfont icon-menu"></i></header></div><script src="/js/navigation.js"></script><div class="container post-index"><div class="post"><div style="position:fixed;right:1em;top:1.5em;cursor:pointer;z-index:999" onclick="toggleTOC()" id="toc"><div style="width:2em;height:2em"><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div></div></div><h1 class="article-title"> <span>10种有用的Linux bash自动补全实例</span></h1><div class="article-top-meta"> <span>发布 : 2017-06-14</span> <span>分类 : <a href="/categories/translations/">translations</a></span> <span>浏览 : <span class="article-timer">--</span></span></div><div class="article-content"><div class="markdown-body"><blockquote><p><a href="http://www.thegeekstuff.com/2013/12/bash-completion-complete/" target="_blank" rel="noopener">原文链接</a></p></blockquote><p>在Linux的终端中，如果敲两次TAB键，就会列出所有可用的命令(<em>如果已经输入了部分字符，就会显示以这些字符为开头的命令</em>)。</p><p>其实这并不新鲜，也许你早就知道了。这个功能被叫做bash自动补全。基础的文件名和目录名自动补全在bash中默认是支持的。</p><p>但是，我们可以升级bash补全，让它进入更高一级的命令补全。</p><p>这篇教程解释了应该怎样通过调用参数自动补全和命令参数的自动补全。</p><p>比如，在敲入<code>write</code>命令后，如果敲两次tab， 自动补全会提供进行write操作的用户的列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ write [TAB][TAB]</span><br><span class="line">bala      raj</span><br><span class="line">jason     randy</span><br><span class="line">john      ritu</span><br><span class="line">mayla     thomas</span><br><span class="line">nisha     www-data</span><br></pre></td></tr></table></figure><p>在下面这个例子中，它会为telnet命令显示有效的主机名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ telnet [TAB][TAB]</span><br><span class="line">localhost  dev-db  fileserver</span><br></pre></td></tr></table></figure><p>要在终端中得到可编程的自动补全功能，只需要像下面这样运行 <em>/etc/bash_completion</em> 就好了(<em>小数点可以用source代替</em>)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ . /etc/bash_completion</span><br></pre></td></tr></table></figure><p>你也可以在 <em>/etc/bash.bashrc</em> (ubuntu linux 13.04) 中取消以下几行的注释，这样你就不用显式的运行上面的命令了:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if ! shopt -oq posix; then</span><br><span class="line">  if [ -f /usr/share/bash-completion/bash_completion ]; then</span><br><span class="line">    . /usr/share/bash-completion/bash_completion</span><br><span class="line">  elif [ -f /etc/bash_completion ]; then</span><br><span class="line">    . /etc/bash_completion</span><br><span class="line">  fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>如果你没有在 <em>/etc/bash_completion</em> 找到上面几行的话，就需要手动安装<code>bash_completion</code>。</p><hr><h3 id="1-查看已有的bash补全"><a href="#1-查看已有的bash补全" class="headerlink" title="1.查看已有的bash补全"></a>1.查看已有的bash补全</h3><p>在开启了bash补全功能之后，会有一套已经定义好的bash补全。<code>complete</code>命令是用来定义bash补全的，要查看已有的补全，可以用下面这条命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ complete -p | less</span><br></pre></td></tr></table></figure><blockquote><p>-p 参数是上面的例子中是可选的，管道操作输出给less是因为输出的结果可能超过一屏，为了方便查看，顾使用less</p></blockquote><h3 id="2-bash提供的标准补全"><a href="#2-bash提供的标准补全" class="headerlink" title="2.bash提供的标准补全"></a>2.bash提供的标准补全</h3><p>bash 默认为Linux用户提供了以下标准补全：</p><ol><li>变量名补全(Variablename)</li><li>用户名补全(Username)</li><li>主机名补全(Hostname)</li><li>路径名补全(Pathname)</li><li>文件名补全(Pathname)</li></ol><blockquote><p>以上补全在<a href="http://www.thegeekstuff.com/2013/11/bash-standard-completion/" target="_blank" rel="noopener">另一篇文章</a>有相关讨论</p></blockquote><h3 id="3-命令-Commands-自动补全"><a href="#3-命令-Commands-自动补全" class="headerlink" title="3.命令(Commands)自动补全"></a>3.命令(Commands)自动补全</h3><p>用 <code>-c</code> 参数来定义获取命令的补全。在下面的例子中，我们为which命令定义了补全：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ complete -c <span class="built_in">which</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">which</span> [TAB][TAB]</span><br><span class="line">Display all 2116 possibilities? (y or n)</span><br></pre></td></tr></table></figure><blockquote><p>输入<code>y</code>，就会得到所有命令的列表</p></blockquote><h3 id="4-目录-Directories-自动补全"><a href="#4-目录-Directories-自动补全" class="headerlink" title="4.目录(Directories)自动补全"></a>4.目录(Directories)自动补全</h3><p>用 <code>-d</code> 参数来定义只获取目录的补全。在下面的例子中，我们为ls定义了这个补全：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">countfiles.sh  dir1/          dir2/          dir3/</span><br><span class="line"></span><br><span class="line">$ complete -d ls</span><br><span class="line"></span><br><span class="line">$ ls [TAB][TAB]</span><br><span class="line">dir1/          dir2/          dir3/</span><br></pre></td></tr></table></figure><blockquote><p>作为对比，可见在定义了新的补全规则后，敲tab就只会出现目录了。</p></blockquote><h3 id="5-后台任务-Jobs-自动补全"><a href="#5-后台任务-Jobs-自动补全" class="headerlink" title="5.后台任务(Jobs)自动补全"></a>5.后台任务(Jobs)自动补全</h3><p>通过补全，同样可以让一个命令获取后台运行的命令的名字作为参数，像下面这样使用 <code>-j</code> 参数就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">jobs</span></span><br><span class="line">[1]-  Stopped                 cat</span><br><span class="line">[2]+  Stopped                 sed <span class="string">'p'</span></span><br><span class="line"></span><br><span class="line">$ complete -j ./list_job_attrib.sh</span><br><span class="line"></span><br><span class="line">$ ./list_job_attrib.sh [TAB][TAB]</span><br><span class="line">cat   sed</span><br></pre></td></tr></table></figure><p>说到后台任务，你也应该知道如何管理<a href="http://www.thegeekstuff.com/2010/05/unix-background-job/" target="_blank" rel="noopener">Linux的后台任务</a>。</p><h3 id="6-前缀、后缀自动补全"><a href="#6-前缀、后缀自动补全" class="headerlink" title="6.前缀、后缀自动补全"></a>6.前缀、后缀自动补全</h3><p>自动补全可以在真正的补全的前面添加想要的前缀，后面添加后缀。在下面的例子中，前缀和后缀的补全规则被用于 <em>list_job_attrib.sh</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">jobs</span> </span><br><span class="line">[1]+  Stopped                 cat</span><br><span class="line"></span><br><span class="line">$ complete -P <span class="string">'"&gt;'</span> -S <span class="string">'&lt;"'</span> ./list_job_attrib.sh</span><br><span class="line"></span><br><span class="line">$ ./list_job_attrib.sh [TAB][TAB]</span><br><span class="line"></span><br><span class="line">$ ./list_job_attrib.sh <span class="string">"&gt;cat&lt;"</span></span><br></pre></td></tr></table></figure><h3 id="7-文件名和目录名的排除补全"><a href="#7-文件名和目录名的排除补全" class="headerlink" title="7.文件名和目录名的排除补全"></a>7.文件名和目录名的排除补全</h3><p>假设某个脚本运行结束后，输出结果像下面这样被输出到了 <em>output</em> 目录中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> output/</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">all_calls.txt   incoming_calls.txt   outgoing_calls.txt   missed_calls.txt parser_mod.tmp  extract.o</span><br></pre></td></tr></table></figure><p>在上面的结果中，如果你想在执行ls的时候，自动补全忽略 <em>.tmp</em> 和 <em>.o</em> 文件，可以这样做:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> FIGNORE=<span class="string">'.tmp:.o'</span></span><br><span class="line"></span><br><span class="line">$ complete -f -d ls</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> output</span><br><span class="line"></span><br><span class="line">$ ls [TAB][TAB]</span><br><span class="line">all_calls.txt   incoming_calls.txt   outgoing_calls.txt   missed_calls.txt</span><br></pre></td></tr></table></figure><p><code>FIGNORE</code>是shell变量，它用来在自动补全结果中排除文件名中包含后缀的文件。</p><h3 id="8-用IFS分割字符串来获取补全值"><a href="#8-用IFS分割字符串来获取补全值" class="headerlink" title="8.用IFS分割字符串来获取补全值"></a>8.用IFS分割字符串来获取补全值</h3><p>单词列表可以用<code>-W</code>参数加上IFS值进行分割，然后每一个分割后的单词都会在补全结果中出现:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> IFS=<span class="string">" "</span></span><br><span class="line"></span><br><span class="line">$ complete -W <span class="string">"bubble quick"</span> ./sort_numbers.sh</span><br><span class="line"></span><br><span class="line">$ ./sort_numbers.sh [TAB][TAB]</span><br><span class="line">bubble   quick</span><br></pre></td></tr></table></figure><p>如上所示，句子通过分隔符进行分割，被展开为单词，所以它也可以像下面这样使用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$SORT_TYPE1</span></span><br><span class="line">bubble</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$SORT_TYPE2</span></span><br><span class="line">quick</span><br><span class="line"></span><br><span class="line">$ complete -W <span class="string">"<span class="variable">$SORT_TYPE1</span> <span class="variable">$SORT_TYPE2</span>"</span> ./sort_numbers.sh</span><br><span class="line">$ ./sort_numbers.sh [TAB][TAB]</span><br><span class="line">bubble   quick</span><br></pre></td></tr></table></figure><h3 id="9-使用自己的函数来生成补全"><a href="#9-使用自己的函数来生成补全" class="headerlink" title="9.使用自己的函数来生成补全"></a>9.使用自己的函数来生成补全</h3><p><code>complete</code>命令允许你使用一个函数来定义补全规则，使用<code>-F</code>参数，传递函数名给<code>complete</code>命令，函数被执行来生成补全规则。例如，函数可以写成下面这个样子:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_parser_options()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">local</span> curr_arg;</span><br><span class="line"></span><br><span class="line">  curr_arg=<span class="variable">$&#123;COMP_WORDS[COMP_CWORD]&#125;</span></span><br><span class="line"></span><br><span class="line">  COMPREPLY=( $(compgen -W <span class="string">'-i --incoming -o --outgoing -m --missed'</span> -- <span class="variable">$curr_arg</span> ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，</p><ol><li><code>COMPREPLY</code>: 保存补全结果的数组</li><li><code>COMP_WORDS</code>: 输入到命令行中的单词数组</li><li><code>COMP_CWORD</code>:<code>COMP_WORDS</code>中的索引，用这个索引，可以获取已经输入的命令行中不同位置的单词</li><li><code>compgen</code>: <code>-W</code>参数获取可能的补全值，然后不同的参数在<code>$current_arg</code>的基础上被选择</li></ol><p>这个函数保存在 <em>parser_option</em> 中，被像下面这样被引用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> parser_option</span><br></pre></td></tr></table></figure><p>将这个函数像下面这样绑定到你的脚本上:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ complete -F _parser_options ./parser.pl</span><br><span class="line"></span><br><span class="line">$ ./parser.pl [TAB][TAB]</span><br><span class="line">-i	--incoming	-o	--outgoing	-m	--missed</span><br></pre></td></tr></table></figure><p>如上所示，补全规则通过<code>_parser_options</code>函数来生成。</p><blockquote><p>提示：查看 <em>/etc/bash_completion</em> 可以获取更多函数来完成你的自定义补全规则</p></blockquote><h3 id="10-当主规则没有生成时的二级规则"><a href="#10-当主规则没有生成时的二级规则" class="headerlink" title="10.当主规则没有生成时的二级规则"></a>10.当主规则没有生成时的二级规则</h3><p>如果主要补全规则没有任何补全匹配结果的时候，那么与之伴随的另一个参数<code>-o</code>的选择将会用于匹配补全规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ complete -F _count_files -o dirnames ./countfiles.sh</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>_count_files</code> 被用来生成 <em>./countfiles.sh</em> 的自动补全规则，如果 <code>_count_files</code> 没有生成任何补全匹配的话，目录名将被作为匹配规则。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls </span><br><span class="line">countfiles.sh    dir1/      dir2/      dir3/</span><br><span class="line"></span><br><span class="line">$./countfiles.sh [TAB][TAB]</span><br><span class="line">dir1    dir2    dir3</span><br></pre></td></tr></table></figure></div></div><div class="copy-right"><div class="markdown-body"><blockquote> 本文作者 : hellflame<br> 原文链接 : <a href="">https://hellflame.github.io/2017/06/14/linux-bash-auto-complete/</a><br> 版权声明 : 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</blockquote></div></div><div class="social-share" style="margin-top:-2rem" data-wechat-qrcode-title="<p>微信扫一扫</p>" data-wechat-qrcode-helper="<p>微信右上角, 扫一扫分享</p>" data-sites="qzone, qq, weibo, facebook, twitter"> <span style="color:#6b7487;font-size:1.4rem">分享到:</span></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js" async></script><div class="article-footer"><div class="article-meta pull-left"><span><i class="iconfont icon-06tags"></i> 标签: <span class="span--tag"><a href="/tags/python/">#python</a></span> <span class="span--tag"><a href="/tags/linux/">#linux</a></span></span></div><div class="article-meta pull-right"></div></div></div><aside id="sidebar"><p id="sidebar-header"></p><ol id="sidebar-toc"></ol></aside><script async>getTOC().length||$("#toc").remove()</script><nav class="post-navigation"><div class="nav-pre"><i class="iconfont icon-prev"></i> 上一篇: <a href="/2017/05/14/qiniu-manager-dev-rec/" target="_self">Qiniu Manager 开发记录</a></div><div class="nav-next"> 下一篇: <a href="/2017/07/22/promise-and-concurrent/" target="_self">Promise.race 和 一种协程优化实现</a><i class="iconfont icon-next"></i></div></nav><a href="#comment" class="comment-anchor"></a><div class="comment-title"><i class="iconfont icon-footprint"></i> 留下足迹<i class="iconfont icon-footprint"></i></div> <a style="margin-bottom:1em;display:block;cursor:pointer" onclick="gotoComment()">点击通过issue留言</a><div id="vcomments"></div><script defer="defer">new Valine({el:"#vcomments",appId:"a",appKey:"b",notify:!1,verify:!1,avatar:"robohash",placeholder:"不填邮箱，网址, 也能收到回复哦♪(^∇^*)\n当然也不一定会回复-_-",path:getRealPath()})</script><script defer="defer">
   function gotoComment() {
    location.href = `https://github.com/hellflame/hellflame.github.io/issues/new?title=关于%0A“10%E7%A7%8D%E6%9C%89%E7%94%A8%E7%9A%84Linux%20bash%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E5%AE%9E%E4%BE%8B”&body=%23%23%23%20[原文地址](https://hellflame.github.io/2017/06/14/linux-bash-auto-complete/)%0A%0A%23%23%23%20想说的话(问题/支持/异议)%20%20%0A%0A${document.getElementById('veditor').value}`
   }
   document.onreadystatechange = (e) => {
     if(document.readyState === 'complete') {
      setTimeout(() => {
        const target = document.getElementsByClassName("vsubmit vbtn")[0]
        target.outerHTML = target.outerHTML
        setTimeout(() => {
          document.getElementsByClassName("vsubmit vbtn")[0].addEventListener('click', gotoComment)
          console.log("event replaced")
        }, 1000)
        document.getElementsByClassName("power txt-right")[0].innerHTML = "Once powered by Valine"
      }, 1000)
     }
   }
 </script></div><footer><p class="site-info"> 博客已萌萌哒运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span><br> Theme - <a target="_blank" href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With 💗 | Powered by GodBMW & hellflame<br></p></footer><script src="/js/footer.js"></script><script>updateUptime(2016,3,27)</script><div class="back-to-top hidden"><span><i class="iconfont icon-60"></i><span></span> %</span></div><script src="/js/component/back-to-top.js"></script></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script src="/js/mathjax.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.js" async></script><script async src="/js/fancybox.js"></script></body></html>