<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>Promise.race 和 一种协程优化实现 | Hellflame</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="basics,web,python,javascript,"><meta name="description" content="pleased or sad, everything dies with hellflame"><link rel="alternate" href="/atom.xml" title="Hellflame" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="apple-touch-icon" href="/images/favicon.png"><link href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="/icon/iconfont.css"><link rel="stylesheet" href="/css/github-markdown.css"><link rel="stylesheet" href="/css/highlight.css"><script src="/js/util.js"></script><script src="/js/valine.min.js"></script><link href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js" async></script><script src="/js/player.js"></script><link href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script></head><body><div id="app"><div class="header-wrap"><header><div class="site-brand"><div class="site-title"> <a href="/">Hellflame</a></div></div><nav class="site-navigation"><ul class="nav-menu"><li class="nav-item" data-path="/"> <a href="/" target="_self">首页</a></li><li class="nav-item" data-path="/archives/"> <a href="/archives/" target="_self">归档</a></li><li class="nav-item" data-path="/categories/"> <a href="/categories/" target="_self">分类</a></li><li class="nav-item" data-path="/tags/"> <a href="/tags/" target="_self">标签</a></li><li class="nav-item" data-path="/friends/"> <a href="/friends/" target="_self">友链</a></li><li class="nav-item" data-path="/corner-story/"> <a href="/corner-story/" target="_self">转角杀</a></li><li class="nav-item" data-path="/about/"> <a href="/about/" target="_self">关于</a></li><li class="nav-item" data-path="https://github.com/hellflame"> <a href="https://github.com/hellflame" target="_self">Github</a></li></ul></nav><i class="iconfont icon-menu"></i></header></div><script src="/js/navigation.js"></script><div class="container post-index"><div class="post"><div style="position:fixed;right:1em;top:1.5em;cursor:pointer;z-index:999" onclick="toggleTOC()" id="toc"><div style="width:2em;height:2em"><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div></div></div><h1 class="article-title"> <span>Promise.race 和 一种协程优化实现</span></h1><div class="article-top-meta"> <span>发布 : 2017-07-22</span> <span>分类 : <a href="/categories/basics/">basics</a></span> <span>浏览 : <span class="article-timer">--</span></span></div><div class="article-content"><div class="markdown-body"><blockquote><p>在这里主要展示了通过 (Python gevent中协程的) 信号量的方式来实现更佳合理的Promise.race的竞争<br>当然，信号量只是一种实现，因为在个人的一个小工具里用了这种方法，于是就现成的放上来了</p></blockquote><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise是抽象异步处理对象以及对其进行各种操作的组件，是ES6原生提供的一个对象。</p><p>在ES6标准之前，一般通过回调的方式完成异步的操作。Promise的出现让之前嵌套的回调有序的展开。</p><p>关于Promise，相关的参考主要来源于<a href="http://liubin.org/promises-book/" target="_blank" rel="noopener">JavaScript Promise迷你书</a></p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race 接受多个promise对象，并且在其中任何一个promise对象变成 <code>FullFilled</code> 或者 <code>Rejected</code> 状态的话就会开始响应后续的操作</p><p><a href="http://liubin.org/promises-book/#ch2-promise-race" target="_blank" rel="noopener">promise.race 实例</a></p><p>由于promise的方法叫 <code>race</code>，在接受了多个 <code>racer</code> 之后会让每一个 <code>racer</code> 都完成它们的生命周期，并不是选出冠军就结束的(可能还需要排名什么的)</p><blockquote><p>在 <a href="http://liubin.org/promises-book/#es6-promises" target="_blank" rel="noopener">ES6 Promises</a> 规范中，没有取消（中断）promise对象执行的概念，我们必须要确保promise最终进入resolve or reject状态之一。也就是说Promise并不适用于 <a href="http://liubin.org/promises-book/#promise-states" target="_blank" rel="noopener">状态</a> 可能会固定不变的处理。也有一些类库提供了对promise进行取消的操作。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example from http://liubin.org/promises-book/#ch2-promise-race</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> winnerPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'this is winner'</span>);</span><br><span class="line">            resolve(<span class="string">'this is winner'</span>);</span><br><span class="line">        &#125;, <span class="number">4</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="keyword">var</span> loserPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'this is loser'</span>);</span><br><span class="line">            resolve(<span class="string">'this is loser'</span>);</span><br><span class="line">        &#125;, <span class="number">10000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">// 第一个promise变为resolve后程序停止</span></span><br><span class="line"><span class="built_in">Promise</span>.race([winnerPromise, loserPromise]).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);    <span class="comment">// =&gt; 'this is winner'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这里的例子可以同时看到三次log出现，两次是winner，一次是loser (10秒之后)。</p><p>所以当问起 <code>race</code> 的适用场景的话，现在还是有一些迷茫(讲真)。race的目的是为了尽快的获取异步过程的处理结果，才让几个promise来赛跑。按照占用资源的类型来分，如果运动员们都是消耗同类资源，无论是偏向计算型还是IO型，都会趋向于把对手挤下去，最终导致大家的处境都不是很好，况且race一定要让每一个运动员都跑完全场，那么计算型的运动员们讲使得用户的本地计算资源消耗翻倍，如果是IO型的，尤其是ajax请求，对于客户端和服务器都会造成流量的浪费和占用。</p><p>当然，race的各个运动员主要占用的也可以是不同类型的资源，一个偏重消耗CPU资源，一个偏重消耗带宽资源。然而，如果各个运动员要实现的目标都是一样的，那么一定还需要一个裁判作为仲裁机构，在冠军产生之后就要将其产出采纳，并且放弃非冠军的结果(即便这个结果可能更好，只是不够快)。在各种资源供给不确定的情况下，这样的确可以简单的获取最快的结果。然而，实际环境中，真的有多少需求是将本地的CPU消耗产物等价换成带宽消耗产物的？</p><p>其实，如果race的运动员们都占用的是同类资源，比如去请求不同服务器同一功能的API(当然，不同的请求可能是简单跨域和复杂跨域，导致请求成功的概率因为浏览器安全策略而异)，只要每个请求不是动不动就要下载几M数据的那种，客户端的带宽也充裕的话，这样的race其实也不错。</p><p>为了解决资源的无谓占用，能够想到的就是在冠军产生之后就把未完成比赛的运动员都淘汰掉，撤销资源。遗憾的是 <code>ES6</code> 中并没有相关定义。<a href="https://stackoverflow.com/questions/29478751/how-to-cancel-an-emcascript6-vanilla-javascript-promise-chain" target="_blank" rel="noopener">How to cancel an EMCAScript6 (vanilla JavaScript) promise chain</a> ，在这个问题中也提到了promise的部分三方实现，<a href="http://bluebirdjs.com/docs/api/cancellation.html#cancellation" target="_blank" rel="noopener">BlueBird - Promise Cancellation</a> 。虽然这个第三方库还没有用过，猜想一下可能出现的安全问题会来自于API请求被撤销之后不确定的状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> previewWithCounter1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> req = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  req.onreadystatechange = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    xxxx</span><br><span class="line">    resolve(req.responseText)</span><br><span class="line">  &#125;</span><br><span class="line">  req.open(<span class="string">"POST"</span>, <span class="string">"http://api1.eg.com"</span>)</span><br><span class="line">  req.send()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> previewWithCounter2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> req = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  req.onreadystatechange = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    xxxx</span><br><span class="line">    resolve(req.responseText)</span><br><span class="line">  &#125;</span><br><span class="line">  req.open(<span class="string">"POST"</span>, <span class="string">"http://api2.eg.com"</span>)</span><br><span class="line">  req.send()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([previewWithCounter1, previewWithCounter2]).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  	kill_the_loser(xxxx);</span><br><span class="line">  	.....</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述例子中，两个请求预览并且为这个资源的预览量+1 的promise在一起race，假定 <code>kill_the_loser</code> 方法能够把不够快的运动员撤销掉，这个时候就需要注意死去的运动员的请求状态了。死去运动员的请求可能还没有发出，肯能已经发出，服务器可能已经接受到了预览量+1的请求，也有可能没有。所以，这里还是不要有写操作的好。</p><p>在promise.race看的差不多之后，终于到了自己有类似需求的时候了。虽然不是前端的需求，只是一个小的爬虫辞典的例子。</p><h3 id="Python中基于信号量的Race"><a href="#Python中基于信号量的Race" class="headerlink" title="Python中基于信号量的Race"></a>Python中基于信号量的Race</h3><p>这个小辞典需要的效果大概是并发的请求可能的三个数据来源，并在任何一个得到有效结果之后结束所有其他来源的请求，如果都没有有效结果的话，最终返回空。</p><p>三个数据来源分别是 本地SQLite、有道词典网页请求和个人搭建的服务器的请求。和promise.race相同的是让多个promise并发执行，并获得最快的响应。不一样的是，我需要的是获得最快的有效响应，并且为了防止某一个请求长时间pending，拖延整个程序的退出时间，每一个请求都有时间限制，并且，输掉比赛，就意味着死亡。</p><p>具体和最新的代码实现放在了<a href="https://github.com/hellflame/youdao/blob/master/youdao/racer.py" target="_blank" rel="noopener">Github-youdao.racer</a> 上面，使用gevent库实现。</p><p>大概的结构是一个大小和运动员数量相等的<a href="https://github.com/hellflame/youdao/blob/v4.0.1/youdao/racer.py#L18" target="_blank" rel="noopener">信号量</a> ，在这里有三个运动员，所以信号量也就是3了。</p><p>以本地SQLite请求为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">local_sql_fetch</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> Timeout(<span class="number">1</span>):</span><br><span class="line">        result = self.sql_saver.query(self.phrase)</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            self.racer_weapon(result, gun=<span class="string">'sql'</span>)</span><br></pre></td></tr></table></figure><p>请求被限制在一定时间内完成，在得到非空结果之后便去拿起运动员的武器，把整个协程池都结束(也就是把运动场都砸了=。=)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">racer_weapon</span><span class="params">(self, bullet, gun)</span>:</span></span><br><span class="line">    self.result = bullet</span><br><span class="line">    <span class="comment"># print gun</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> gun == <span class="string">'sql'</span> <span class="keyword">and</span> <span class="string">'possibles'</span> <span class="keyword">not</span> <span class="keyword">in</span> bullet:</span><br><span class="line">        self.sql_saver.upset(self.phrase, bullet)</span><br><span class="line">        self.pool.kill()</span><br></pre></td></tr></table></figure><p>当然，由于非冠军的运动员被砸场的时候的运行进度是一个谜，所以，大家的操作最好都是只读的。在youdao的这个小工具里，个人的私有定制化服务器并没有完全遵守这一规则，主要是因为个人服务器相对于客户端可以异步的从有道官网获取查询数据，存储到服务器的Mongodb，以备后续其他人可能的相同查询(如果这个查询结果没有提前到达客户端，那么就只能造福其他人了)。</p><p>另外，如果要忽略每一位运动员的比赛结果的话(有可能没有运动员能顺利结束比赛，都没有机会捡起砸场武器)，也就是更接近 <code>promise.race</code> 的话，无论是 <code>FullFilled</code> 还是 <code>Rejected</code> 状态，都要将这个值作为整个比赛的结果的话，可以添加一名额外的运动员在其他运动员之后。比如当前信号量的跑道只够三名运动员比赛，那么多出来的砸场人员只能待命，直到有运动员得出比赛结果，那么这名砸场人员就可以拿到信号量，把整个协程池结束掉。好吧，依然没有想要让每个运动员都像 <code>promise.race</code> 一样跑完全场。</p><p>最后，如果的确需要达到 <code>promise.race</code> 同样的效果，也就是各个运动员并发运动，获得最快的响应，但是不会砸场的话，只需要这些协程并发，然后在每一个协程结束之前调用一个共有方法，将结果传递给它，并且记录在案，接收并且只接受一个结果就可以了。 <strong>中间可以不需要信号量的存在。</strong></p><p>总结而言，其实要实现</p><ul><li>并发执行(运动员们同时开跑)</li><li>最快响应(获得冠军成绩)</li></ul><p>的话，信号量只是一种限制手段，保证协程池(或者线程池等)足够容纳所有协程(或者线程等)，就能够让他们并发执行(也就是跑道足够多)，要获得最快的响应的话，只需要在最快的运动员跑完之后进行唯一性的记录，忽略其他运动员的成绩就可以了。</p><p>如果只是图快，只要有协程(或者线程等)运行结束，无论成功与否，把额外的协程(或线程等)加入到协程池(或线程池)中来打扫战场就好了</p><p>一切都只是为了更快，更节约资源。</p></div></div><div class="copy-right"><div class="markdown-body"><blockquote> 本文作者 : hellflame<br> 原文链接 : <a href="">https://hellflame.github.io/2017/07/22/promise-and-concurrent/</a><br> 版权声明 : 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</blockquote></div></div><div class="social-share" style="margin-top:-2rem" data-wechat-qrcode-title="<p>微信扫一扫</p>" data-wechat-qrcode-helper="<p>微信右上角, 扫一扫分享</p>" data-sites="qzone, qq, weibo, facebook, twitter"> <span style="color:#6b7487;font-size:1.4rem">分享到:</span></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js" async></script><div class="article-footer"><div class="article-meta pull-left"><span><i class="iconfont icon-06tags"></i> 标签: <span class="span--tag"><a href="/tags/web/">#web</a></span> <span class="span--tag"><a href="/tags/python/">#python</a></span> <span class="span--tag"><a href="/tags/javascript/">#javascript</a></span></span></div><div class="article-meta pull-right"></div></div></div><aside id="sidebar"><p id="sidebar-header"></p><ol id="sidebar-toc"></ol></aside><script async>getTOC().length||$("#toc").remove()</script><nav class="post-navigation"><div class="nav-pre"><i class="iconfont icon-prev"></i> 上一篇: <a href="/2017/06/14/linux-bash-auto-complete/" target="_self">10种有用的Linux bash自动补全实例</a></div><div class="nav-next"> 下一篇: <a href="/2017/08/26/wired-hash/" target="_self">奇怪的哈希</a><i class="iconfont icon-next"></i></div></nav><a href="#comment" class="comment-anchor"></a><div class="comment-title"><i class="iconfont icon-footprint"></i> 留下足迹<i class="iconfont icon-footprint"></i></div> <a style="margin-bottom:1em;display:block;cursor:pointer" onclick="gotoComment()">点击通过issue留言</a><div id="vcomments"></div><script defer="defer">new Valine({el:"#vcomments",appId:"a",appKey:"b",notify:!1,verify:!1,avatar:"robohash",placeholder:"不填邮箱，网址, 也能收到回复哦♪(^∇^*)\n当然也不一定会回复-_-",path:getRealPath()})</script><script defer="defer">
   function gotoComment() {
    location.href = `https://github.com/hellflame/hellflame.github.io/issues/new?title=关于%0A“Promise.race%20%E5%92%8C%20%E4%B8%80%E7%A7%8D%E5%8D%8F%E7%A8%8B%E4%BC%98%E5%8C%96%E5%AE%9E%E7%8E%B0”&body=%23%23%23%20[原文地址](https://hellflame.github.io/2017/07/22/promise-and-concurrent/)%0A%0A%23%23%23%20想说的话(问题/支持/异议)%20%20%0A%0A${document.getElementById('veditor').value}`
   }
   document.onreadystatechange = (e) => {
     if(document.readyState === 'complete') {
      setTimeout(() => {
        const target = document.getElementsByClassName("vsubmit vbtn")[0]
        target.outerHTML = target.outerHTML
        setTimeout(() => {
          document.getElementsByClassName("vsubmit vbtn")[0].addEventListener('click', gotoComment)
          console.log("event replaced")
        }, 1000)
        document.getElementsByClassName("power txt-right")[0].innerHTML = "Once powered by Valine"
      }, 1000)
     }
   }
 </script></div><footer><p class="site-info"> 博客已萌萌哒运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span><br> Theme - <a target="_blank" href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With 💗 | Powered by GodBMW & hellflame<br></p></footer><script src="/js/footer.js"></script><script>updateUptime(2016,3,27)</script><div class="back-to-top hidden"><span><i class="iconfont icon-60"></i><span></span> %</span></div><script src="/js/component/back-to-top.js"></script></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script src="/js/mathjax.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.js" async></script><script async src="/js/fancybox.js"></script></body></html>