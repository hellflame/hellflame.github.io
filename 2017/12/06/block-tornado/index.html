<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>阻塞的Tornado | Hellflame</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="basics,python,"><meta name="description" content="pleased or sad, everything dies with hellflame"><link rel="alternate" href="/atom.xml" title="Hellflame" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="apple-touch-icon" href="/images/favicon.png"><link href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="/icon/iconfont.css"><link rel="stylesheet" href="/css/github-markdown.css"><link rel="stylesheet" href="/css/highlight.css"><script src="/js/util.js"></script><script src="/js/valine.min.js"></script><link href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js" async></script><script src="/js/player.js"></script><link href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script></head><body><div id="app"><div class="header-wrap"><header><div class="site-brand"><div class="site-title"> <a href="/">Hellflame</a></div></div><nav class="site-navigation"><ul class="nav-menu"><li class="nav-item" data-path="/"> <a href="/" target="_self">首页</a></li><li class="nav-item" data-path="/archives/"> <a href="/archives/" target="_self">归档</a></li><li class="nav-item" data-path="/categories/"> <a href="/categories/" target="_self">分类</a></li><li class="nav-item" data-path="/tags/"> <a href="/tags/" target="_self">标签</a></li><li class="nav-item" data-path="/friends/"> <a href="/friends/" target="_self">友链</a></li><li class="nav-item" data-path="/corner-story/"> <a href="/corner-story/" target="_self">转角杀</a></li><li class="nav-item" data-path="/about/"> <a href="/about/" target="_self">关于</a></li><li class="nav-item" data-path="https://github.com/hellflame"> <a href="https://github.com/hellflame" target="_self">Github</a></li></ul></nav><i class="iconfont icon-menu"></i></header></div><script src="/js/navigation.js"></script><div class="container post-index"><div class="post"><div style="position:fixed;right:1em;top:1.5em;cursor:pointer;z-index:999" onclick="toggleTOC()" id="toc"><div style="width:2em;height:2em"><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div></div></div><h1 class="article-title"> <span>阻塞的Tornado</span></h1><div class="article-top-meta"> <span>发布 : 2017-12-06</span> <span>分类 : <a href="/categories/basics/">basics</a></span> <span>浏览 : <span class="article-timer">--</span></span></div><div class="article-content"><div class="markdown-body"><p>python-tornado 相对于其他的网络框架，最为人知的特点就是异步网络和非阻塞I/O，以及以用同步的方式写异步的代码等<a href="http://www.tornadoweb.org/en/stable/" target="_blank" rel="noopener">Tornado</a> 。然鹅，在最自然(不做特别处理)的情况下，Tornado 其实是阻塞的。</p><p>先看一个阻塞的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.write(<span class="string">"index"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blocking</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line">        self.write(<span class="string">"blocking"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tornado.web.Application(handlers=[</span><br><span class="line">        (<span class="string">'/'</span>, IndexHandler),</span><br><span class="line">        (<span class="string">'/blocking'</span>, Blocking)</span><br><span class="line">    ], autoreload=<span class="keyword">True</span>).listen(<span class="number">5000</span>, <span class="string">'localhost'</span>)</span><br><span class="line">    tornado.ioloop.IOLoop().current().start()</span><br></pre></td></tr></table></figure><p>如果先访问 <code>localhost:5000/blocking</code>，那么在接下来的10s内再访问 <code>localhost:5000</code> 就会发现一直没有相应，一直到等到 10s 结束，处理完 <code>blocking</code> 的请求。(虽然这并不是一个正确的例子，但是接下来记录的正是对<code>协程</code>的进一步理解)</p><p>通过各方搜索，肯定能够找到下面的方法来解决整个Tornado阻塞在这个阻塞请求上:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.write(<span class="string">"index"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blocking</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># time.sleep(10)</span></span><br><span class="line">        <span class="keyword">yield</span> gen.sleep(<span class="number">10</span>)</span><br><span class="line">        self.write(<span class="string">"blocking"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tornado.web.Application(handlers=[</span><br><span class="line">        (<span class="string">'/'</span>, IndexHandler),</span><br><span class="line">        (<span class="string">'/blocking'</span>, Blocking)</span><br><span class="line">    ], autoreload=<span class="keyword">True</span>).listen(<span class="number">5000</span>, <span class="string">'localhost'</span>)</span><br><span class="line">    tornado.ioloop.IOLoop().current().start()</span><br></pre></td></tr></table></figure><p>此时再次先访问 <code>localhost:5000/blocking</code> ，会发现访问这个请求的时候依然需要等待10s才会有响应，然而不同的是在这期间访问 <code>localhost:5000</code> 变的很顺畅，就像网站上没有什么阻塞的事件在运行一样(实际上也并没有)。大多数人在这里就开始笃信tornado中异步的强大，以及用 <code>协程</code> 将阻塞变成非阻塞的万能(就像当年的我23333)，其实这里只是用错了栗子。之所以说用错，是因为 <code>gen.sleep</code> 并不是将原本阻塞的方法变成了非阻塞，只是偷换了 <code>time.sleep</code> 的同步性，取而代之延迟执行的表象。</p><p>查看一下 tornado 中 <code>gen.sleep</code>究竟做了什么，就会发现:</p><p><a href="https://github.com/tornadoweb/tornado/blob/5fcfb4277514ff82e2d3b17a24a26ed505b8d453/tornado/gen.py#L950" target="_blank" rel="noopener">gen.sleep 源码片段</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(duration)</span>:</span></span><br><span class="line">    <span class="string">"""Return a `.Future` that resolves after the given number of seconds.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    When used with ``yield`` in a coroutine, this is a non-blocking</span></span><br><span class="line"><span class="string">    analogue to `time.sleep` (which should not be used in coroutines</span></span><br><span class="line"><span class="string">    because it is blocking)::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        yield gen.sleep(0.5)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Note that calling this function on its own does nothing; you must</span></span><br><span class="line"><span class="string">    wait on the `.Future` it returns (usually by yielding it).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. versionadded:: 4.1</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    f = Future()</span><br><span class="line">    IOLoop.current().call_later(duration, <span class="keyword">lambda</span>: f.set_result(<span class="keyword">None</span>))</span><br><span class="line">    <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure><p>这个 <code>sleep</code> 并没有真的sleep，只是在事件循环中添加了一个延迟的回调，如果遇到真的需要(连续不断)占用炒鸡长时间的任务运行，整个网站一定会阻塞。其实仔细想想也并不困难，单开一个Tornado进程，没有多线程，整个网站也只能在单线程环境下运行，如果某一个任务毫无间断地在整个网站的时间片上运行，当然会造成阻塞。于是乎，接下来能想到的处理方法就是多线程的方法了，tornado也支持这种方式实现多线程非阻塞。修改之后的代码可能类似这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> tornado.concurrent <span class="keyword">import</span> run_on_executor</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.write(<span class="string">"index"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blocking</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    executor = ThreadPoolExecutor(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @run_on_executor</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line">        self.write(<span class="string">"blocking"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tornado.web.Application(handlers=[</span><br><span class="line">        (<span class="string">'/'</span>, IndexHandler),</span><br><span class="line">        (<span class="string">'/blocking'</span>, Blocking)</span><br><span class="line">    ], autoreload=<span class="keyword">True</span>).listen(<span class="number">5000</span>, <span class="string">'localhost'</span>)</span><br><span class="line">    tornado.ioloop.IOLoop().current().start()</span><br></pre></td></tr></table></figure><p>完全不需要 tornado 协程的支持，只需要一个额外的线程池就好了，这样也能达到曾经用协程时候的效果，而且这次是真的非阻塞了，毕竟阻塞的任务跑在了其他线程上。这里用到了python2没有自带的 <code>concurrent</code> 库，python2下面需要额外安装。然而，C Python中的多线程涉及到的GIL依然会导致依赖计算资源的任务阻塞整个进程。于是还会有更多基于消息队列(比如 Celery、Redis)的方式，在分布式的环境中减少阻塞的发生。当然，我并不会继续沿着这条路走下去了，如此下去整个网站的确会表现优异，然而，各种程序依赖不仅会降低可控性，提高维护难度，也减少了思考的余地。</p><p>最近就走到了这步余地。刚刚修好一个问题，到了午饭时间，就看到老大眉头紧皱的来跟我说，”我发现了一个很大的bug”。话还没说完，我也是心里一紧，难道是把自己的漏洞越修越大了咩=。=，”我发现Tornado是阻塞的”。于是之后才花了时间一起探索了一番tornado的协程异步。就在准备用线程池来暂时解决问题的时候，忽然想起来同样用协程来解决问题的 <code>gevent</code> ，中的一个栗子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey; monkey.patch_socket()</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">print</span> i</span><br><span class="line">        gevent.sleep(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">gevent.joinall([gevent.spawn(f, <span class="number">5</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>)])</span><br></pre></td></tr></table></figure><p>其中有关键的一句 <code>gevent.sleep(0)</code>，表面上看毫无作用(睡了0 s)，然而实际作用却是关键的，能够让任务从协程中切换出来。再想想一般将生成器当作协程来用的时候通过 <code>yield</code> 将协程切换出来，以及 Tornado 中的协程异步其实也是通过 <code>yield</code> 进行协程调度，那么再看看 <code>time.sleep(10)</code> 之所以在使用了传说中的非阻塞魔法之后依然发生阻塞，就会发现，真正的原因其实是 <code>time.sleep(10)</code> 过于庞大，并且没有协程插手进行调度的余地。把这个阻塞的方法换成这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blocking</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">            <span class="keyword">yield</span> time.sleep(<span class="number">0.01</span>)</span><br><span class="line">        self.write(<span class="string">"blocking"</span>)</span><br></pre></td></tr></table></figure><p>就会发现虽然也是用的 <code>time.sleep</code> 这个阻塞方法，但是并没有阻塞现象(因为只阻塞了0.01s就去响应 <code>/</code>路径去了)。当然，这是最简单的将阻塞变成非阻塞的情况，实际上肯定会在其他地方完成逻辑响应，将结果交给 tornado去响应给请求。比如这样:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blocking</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">yield</span> sleepy()</span><br><span class="line">        self.write(<span class="string">"blocking"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleepy</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        <span class="keyword">yield</span> time.sleep(<span class="number">0.01</span>)</span><br></pre></td></tr></table></figure><p>然而对于消耗CPU资源(计算型)的任务而言，首先能不能找到这个协程切换的点很难说，然后这个计算型的协程会不会被切换更是另外一回事。协程并不是万能的，再怎么说也只有一个线程在运行，再加上 python 运行效率的低下，大多数人没有停留在协程上还是没有问题的。</p></div></div><div class="copy-right"><div class="markdown-body"><blockquote> 本文作者 : hellflame<br> 原文链接 : <a href="">https://hellflame.github.io/2017/12/06/block-tornado/</a><br> 版权声明 : 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</blockquote></div></div><div class="social-share" style="margin-top:-2rem" data-wechat-qrcode-title="<p>微信扫一扫</p>" data-wechat-qrcode-helper="<p>微信右上角, 扫一扫分享</p>" data-sites="qzone, qq, weibo, facebook, twitter"> <span style="color:#6b7487;font-size:1.4rem">分享到:</span></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js" async></script><div class="article-footer"><div class="article-meta pull-left"><span><i class="iconfont icon-06tags"></i> 标签: <span class="span--tag"><a href="/tags/python/">#python</a></span></span></div><div class="article-meta pull-right"></div></div></div><aside id="sidebar"><p id="sidebar-header"></p><ol id="sidebar-toc"></ol></aside><script async>getTOC().length||$("#toc").remove()</script><nav class="post-navigation"><div class="nav-pre"><i class="iconfont icon-prev"></i> 上一篇: <a href="/2017/10/06/python-optimize/" target="_self">Python 调优策略</a></div><div class="nav-next"> 下一篇: <a href="/2018/12/31/2018-end/" target="_self">在即将结束的2018年</a><i class="iconfont icon-next"></i></div></nav><a href="#comment" class="comment-anchor"></a><div class="comment-title"><i class="iconfont icon-footprint"></i> 留下足迹<i class="iconfont icon-footprint"></i></div> <a style="margin-bottom:1em;display:block;cursor:pointer" onclick="gotoComment()">通过issue留言</a><div id="vcomments"></div><script defer="defer">new Valine({el:"#vcomments",appId:"a",appKey:"b",notify:!1,verify:!1,avatar:"robohash",placeholder:"不填邮箱，网址, 也能收到回复哦♪(^∇^*)\n当然也不一定会回复-_-",path:getRealPath()})</script><script defer="defer">
   function gotoComment() {
    location.href = `https://github.com/hellflame/hellflame.github.io/issues/new?title=关于%0A“%E9%98%BB%E5%A1%9E%E7%9A%84Tornado”&body=%23%23%23%20[原文地址](https://hellflame.github.io/2017/12/06/block-tornado/)%0A%0A%23%23%23%20想说的话(问题/支持/异议)%20%20%0A%0A${document.getElementById('veditor').value}`
   }
   document.onreadystatechange = (e) => {
     if(document.readyState === 'complete') {
      setTimeout(() => {
        const target = document.getElementsByClassName("vsubmit vbtn")[0]
        target.outerHTML = target.outerHTML
        setTimeout(() => {
          document.getElementsByClassName("vsubmit vbtn")[0].addEventListener('click', gotoComment)
          console.log("event replaced")
        }, 1000)
        document.getElementsByClassName("power txt-right")[0].innerHTML = "Once powered by Valine"
      }, 1000)
     }
   }
 </script></div><footer><p class="site-info"> 博客已萌萌哒运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span><br> Theme - <a target="_blank" href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With 💗 | Powered by GodBMW & hellflame<br></p></footer><script src="/js/footer.js"></script><script>updateUptime(2016,3,27)</script><div class="back-to-top hidden"><span><i class="iconfont icon-60"></i><span></span> %</span></div><script src="/js/component/back-to-top.js"></script></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script src="/js/mathjax.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.js" async></script><script async src="/js/fancybox.js"></script></body></html>