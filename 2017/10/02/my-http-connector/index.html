<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>我的HTTP下载库 | Hellflame</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="diaries,python,"><meta name="description" content="pleased or sad, everything dies with hellflame"><link rel="alternate" href="/atom.xml" title="Hellflame" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="apple-touch-icon" href="/images/favicon.png"><link href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="/icon/iconfont.css"><link rel="stylesheet" href="/css/github-markdown.css"><link rel="stylesheet" href="/css/highlight.css"><script src="/js/util.js"></script><script src="/js/valine.min.js"></script><link href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js" async></script><script src="/js/player.js"></script><link href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script></head><body><div id="app"><div class="header-wrap"><header><div class="site-brand"><div class="site-title"> <a href="/">Hellflame</a></div></div><nav class="site-navigation"><ul class="nav-menu"><li class="nav-item" data-path="/"> <a href="/" target="_self">首页</a></li><li class="nav-item" data-path="/archives/"> <a href="/archives/" target="_self">归档</a></li><li class="nav-item" data-path="/categories/"> <a href="/categories/" target="_self">分类</a></li><li class="nav-item" data-path="/tags/"> <a href="/tags/" target="_self">标签</a></li><li class="nav-item" data-path="/friends/"> <a href="/friends/" target="_self">友链</a></li><li class="nav-item" data-path="/corner-story/"> <a href="/corner-story/" target="_self">转角杀</a></li><li class="nav-item" data-path="/about/"> <a href="/about/" target="_self">关于</a></li><li class="nav-item" data-path="https://github.com/hellflame"> <a href="https://github.com/hellflame" target="_self">Github</a></li></ul></nav><i class="iconfont icon-menu"></i></header></div><script src="/js/navigation.js"></script><div class="container post-index"><div class="post"><div style="position:fixed;right:1em;top:1.5em;cursor:pointer;z-index:999" onclick="toggleTOC()" id="toc"><div style="width:2em;height:2em"><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div></div></div><h1 class="article-title"> <span>我的HTTP下载库</span></h1><div class="article-top-meta"> <span>发布 : 2017-10-02</span> <span>分类 : <a href="/categories/diaries/">diaries</a></span> <span>浏览 : <span class="article-timer">--</span></span></div><div class="article-content"><div class="markdown-body"><blockquote><p>由于当时在写七牛云的终端管理助手，但当时七牛云对python SDK的定位一直都是服务端使用，没有对于我这样的终端使用者的考虑，所以在用了一段时间的官方SDK，在一次更新了SDK后，终端出现了很多的调试信息输出，于是终于忍不住开始自己适配七牛服务器的调用API，然而当时也还年轻，没有仔细看看requests，于是就开始了自己处理HTTP报文，一路上停停顿顿的，看看提交代码的history，竟然自那以来已经1年了！</p></blockquote><p>现在这个http库的部分功能正在 <a href="https://github.com/hellflame/qiniu_manager/blob/master/qiniuManager/http.py" target="_blank" rel="noopener">qiniuManager</a> 里发挥作用，或者说发挥最基本的发起HTTP请求和获取HTTP响应的作用，这个也是自己管理服务器远程备份的主要工具了(时不时偶尔登录七牛提供的网页工具，发现还是自己写的工具用起来比较顺手)，所以如果出现什么问题的话，也能尽快修复(这个HTTP下载库)。以下将回忆记录下这个http下载库的坎坷路程。</p><p>先说说 <code>http下载库</code> 这个名字好了，好吧，其实是临时想出来的名字，实际上是一个和 <code>urllib</code> 功能相仿的小工具，然而功能却是完全根据自己的需要添加上去的，本身根本没有从项目中独立出来，毕竟怎么好意思把这么一个阉割版本的 <code>urllib</code> 工具拿出来。然而，正因为是阉割版本，只留下了自己需要的方法，某种程度上来说，算是精兵简政，再加上自己需要的方法，能让功能更紧凑，耦合程度略有提高。虽然如此，以下还是暂时用 <code>HTTP下载库</code> 和 <code>小工具</code> 来指代它好了～</p><p>既然是 http库，最基本的功能当然是发送请求和获取响应，当然也就离不开自己构造请求报文和解析响应报文了。与这个小工具相耦合的功能，就是一个可以在终端显示出来的 <code>进度条</code> ，这个功能也是要做这个小工具的重要目的之一。</p><p>在http请求中，这里指保留了最常用的 <code>GET</code> 和 <code>POST</code> 方法，或者说只考虑了最常用的 <code>GET</code> ，兼容了 <code>POST</code> 方法(后来发现post方法中多了两次换行结尾，导致服务器记录下错误信息，但是没有报 <code>400错误</code> =.=，只是记录下了问题)。正常情况下，在完成请求行之后，再用 <code>\r\n</code> 连接 <code>headers</code> ，再考虑如果是 POST 方法的话，加上一个关于报文实体长度的 header : <code>Content-Length: xxx</code> ，在 headers 结束之后接一个 <code>\r\n</code> + 报文实体，最后把请求用TCP发送给服务器就好了，请求的过程就跟用 <code>telnet</code> 一样顺畅，最多再考虑考虑是否用 <code>SSL</code> 包裹 socket 就好了。</p><p>重点当然是在于获取并解析http响应报文。</p><p>由于响应报文 <code>headers</code> 中还有很多换行符 <code>CRLF</code> ，所以在一开始的时候比较偷懒，我把请求全都放进了一个 StringIO，然后一次一次的 readline。后来想用同样的方法处理 <code>chunked 编码</code> ，发现想要得到当前stringio 已经缓存了多少数据很烦，于是就放弃了对 分块编码 的支持(为什么现在想起来一切都辣么简单，曾经却辣么复杂=。=)。最重要的问题是，<code>StringIO</code> 需要接收字符串作为数据输入，这对于py2来说没什么，但是对于py3就不是了，socket.recv 返回的数据为 bytes 类型，如果强行解码为字符串，对于二进制内容来说必定会导致错误，如果忽略错误，将导致数据丢失，这也是最终放弃了使用 <code>StringIO</code> 的原因，直接使用了 <code>bytes</code> 。</p><p>对于响应报文的headers，处理很平实，由于不知道是否把headers和响应行都接受完了，所以需要把一开始的响应都缓存起来，判断是否有headers的结束标志 <code>CRLF</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> self.status:</span><br><span class="line">  self.raw_head += data</span><br><span class="line">  <span class="keyword">if</span> <span class="string">b'\r\n\r\n'</span> <span class="keyword">in</span> self.raw_head:  <span class="comment"># 接收数据直到 `\r\n\r\n` 为止</span></span><br><span class="line">    seps = self.raw_head[<span class="number">0</span>: self.raw_head.index(<span class="string">b'\r\n\r\n'</span>)].split(<span class="string">b'\r\n'</span>)</span><br><span class="line">    status = seps[<span class="number">0</span>].split(<span class="string">b' '</span>)</span><br><span class="line">    self.status = &#123;</span><br><span class="line">      <span class="string">'status'</span>: seps[<span class="number">0</span>],</span><br><span class="line">      <span class="string">'code'</span>: status[<span class="number">1</span>],</span><br><span class="line">      <span class="string">'version'</span>: status[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> self.file_handle <span class="keyword">and</span> <span class="keyword">not</span> self.status[<span class="string">'code'</span>] == <span class="string">b'200'</span>:</span><br><span class="line">      self.clean_failed_file()</span><br><span class="line">      self.finish_loop()</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    self.headers = &#123;</span><br><span class="line">      i.split(<span class="string">b":"</span>)[<span class="number">0</span>]: i.split(<span class="string">b":"</span>)[<span class="number">1</span>].strip() <span class="keyword">for</span> i <span class="keyword">in</span> seps[<span class="number">1</span>:]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于报文实体，首先需要判断是否为分块编码，并由此决定了进度条的目标点 <code>self.total</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">b'Content-Length'</span> <span class="keyword">in</span> self.headers:</span><br><span class="line">  self.total = int(self.headers[<span class="string">b'Content-Length'</span>])</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    self.total = <span class="number">100</span></span><br><span class="line">    self.chunked = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>当然，socket.recv 并不可能只把 响应行和headers 接收下来，多半会带有部分的报文实体，于是还有处理完headers之后剩下的实体部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left = self.raw_head[self.raw_head.index(<span class="string">b"\r\n\r\n"</span>) + <span class="number">4</span>:]</span><br></pre></td></tr></table></figure><p>接下来就是接收实体部分了。对于普通编码的实体而言，只需要直接保存数据就好了，至于是保存进文件还是 bytes，由 <code>save_data</code> 来处理了；对于分块编码，在存储之前还需要把每一个分块的大小标识去除。</p><p>在处理 <a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">分块编码</a> 时，仔细想想的话，这个分块大小标志并不能随便去除，否则不知道当前分块有多大，万一传输的数据中刚好就有类似的标志怎么办，然后就会导致数据丢失(这也是一开始觉得比较难处理的地方)，还会有数据块中显示包含 <code>\r\n</code> 的情况；不能排除socket.recv了多少，可能出现下面的情况:</p><ul><li>刚好接收完一个分组：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">ab</span><br></pre></td></tr></table></figure><ul><li>接收了多个分组：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line">abcd</span><br></pre></td></tr></table></figure><ul><li>分组不完整</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8f</span><br><span class="line">lkajsdjl (后面还没收到)</span><br></pre></td></tr></table></figure><ul><li>分组的大小标志断开</li></ul><p>上一次socket.recv:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>这一次socket.recv</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">jlaksjd.....</span><br></pre></td></tr></table></figure><p><code>7b</code> 被分割到了两次recv中</p><ul><li>一次性接收完了所有分组:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">0</span><br></pre></td></tr></table></figure><blockquote><p>所以说，如果每当接收一次数据(socket.recv) 就开始处理的话，一定会出现很多情况需要处理，曾经因为这些复杂的情况，索性放弃了chunked编码的支持</p></blockquote><p>然而要解决上面辣么多情况，其实也并不复杂：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flush_chunk</span><span class="params">(self, data)</span>:</span></span><br><span class="line">  self.current_chunk += data</span><br><span class="line">  self.progressed = random.randrange(<span class="number">20</span>, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> len(self.current_chunk) &gt; <span class="number">10240</span> <span class="keyword">or</span> self.current_chunk.endswith(<span class="string">b'0\r\n\r\n'</span>):  <span class="comment"># 并不意味着所有分块结束</span></span><br><span class="line">    <span class="comment"># 开始解析当前chunk cache</span></span><br><span class="line">    chunk_head = self.current_chunk[: self.current_chunk.index(<span class="string">b'\r\n'</span>)]</span><br><span class="line">    chunk_left = self.current_chunk[self.current_chunk.index(<span class="string">b'\r\n'</span>) + <span class="number">2</span>:]</span><br><span class="line">    chunk_size = int(chunk_head, <span class="number">16</span>)</span><br><span class="line">    <span class="keyword">if</span> chunk_size == <span class="number">0</span>:</span><br><span class="line">      self.finish_loop()</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">if</span> chunk_size &gt; len(chunk_left):</span><br><span class="line">      <span class="comment"># 说明当前分块没有接收完全</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    self.save_data(chunk_left[: chunk_size])</span><br><span class="line">    self.current_chunk = chunk_left[chunk_size:]</span><br><span class="line">    <span class="keyword">if</span> self.current_chunk.startswith(<span class="string">b'\r\n'</span>):</span><br><span class="line">      <span class="comment"># 如果上一个分块没有吃掉最后的 \r\n，则在这里把它剔除</span></span><br><span class="line">      self.current_chunk = self.current_chunk[<span class="number">2</span>:]</span><br></pre></td></tr></table></figure><p>嗯，就是需要缓存下一个足够进行下一步存储的缓存块，这样就没有了分块大小标志被生生分开的情况，并且如果当前分块的大小标志显示的大小要大于已经缓存的数据大小的话，说明这个分块还没有准备好被处理，需要进一步接收 socket.recv 的数据。<code>self.current_chunk.endswith(b&#39;0\r\n\r\n&#39;)</code> 并不一定是响应结束的标志，因为不能排除这就是实体的一部分，一定要严格从分块编码的分块大小到分块实体的顺序，判断到显示分块大小为0，才能结束整个recv的循环，最后，剩下的部分由 <code>finish_loop</code> 来结束，里面包含着断开连接和关闭文件的工作，如果不关闭文件，测试的时候就会知道出什么问题了。由于当年没有想到还有缓存这一招，导致很长一段时间搁置了分块编码的支持，直到最近又开始自己的静态文件服务器的管理，一定需要支持分块编码，不得不好好想想了。现在的问题就是分块编码的时候怎么来显示进度条了。</p><p>顺便一说，由于服务器资源有限，对于很大的文件的传输，必须传输分块编码，不然内存就吃不消了，当前，这个网站的所有文章中的图片资源都是来自这个静态文件服务器，虽然下次升级的时候可能又是另一番功夫了。</p><p>以上，感觉还是有很多东西需要学习的。</p><blockquote><p>现在有三个项目有依赖这个下载库，每次更新都要三个一起更新，，我在犹豫要不要把它独立成库了=。=</p></blockquote></div></div><div class="copy-right"><div class="markdown-body"><blockquote> 本文作者 : hellflame<br> 原文链接 : <a href="">https://hellflame.github.io/2017/10/02/my-http-connector/</a><br> 版权声明 : 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</blockquote></div></div><div class="social-share" style="margin-top:-2rem" data-wechat-qrcode-title="<p>微信扫一扫</p>" data-wechat-qrcode-helper="<p>微信右上角, 扫一扫分享</p>" data-sites="qzone, qq, weibo, facebook, twitter"> <span style="color:#6b7487;font-size:1.4rem">分享到:</span></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js" async></script><div class="article-footer"><div class="article-meta pull-left"><span><i class="iconfont icon-06tags"></i> 标签: <span class="span--tag"><a href="/tags/python/">#python</a></span></span></div><div class="article-meta pull-right"></div></div></div><aside id="sidebar"><p id="sidebar-header"></p><ol id="sidebar-toc"></ol></aside><script async>getTOC().length||$("#toc").remove()</script><nav class="post-navigation"><div class="nav-pre"><i class="iconfont icon-prev"></i> 上一篇: <a href="/2017/08/26/wired-hash/" target="_self">奇怪的哈希</a></div><div class="nav-next"> 下一篇: <a href="/2017/10/06/python-optimize/" target="_self">Python 调优策略</a><i class="iconfont icon-next"></i></div></nav><a href="#comment" class="comment-anchor"></a><div class="comment-title"><i class="iconfont icon-footprint"></i> 留下足迹<i class="iconfont icon-footprint"></i></div> <a style="margin-bottom:1em;display:block;cursor:pointer" onclick="gotoComment()">点击通过issue留言</a><div id="vcomments"></div><script defer="defer">new Valine({el:"#vcomments",appId:"a",appKey:"b",notify:!1,verify:!1,avatar:"robohash",placeholder:"不填邮箱，网址, 也能收到回复哦♪(^∇^*)\n当然也不一定会回复-_-",path:getRealPath()})</script><script defer="defer">
   function gotoComment() {
    location.href = `https://github.com/hellflame/hellflame.github.io/issues/new?title=关于%0A“%E6%88%91%E7%9A%84HTTP%E4%B8%8B%E8%BD%BD%E5%BA%93”&body=%23%23%23%20[原文地址](https://hellflame.github.io/2017/10/02/my-http-connector/)%0A%0A%23%23%23%20想说的话(问题/支持/异议)%20%20%0A%0A${document.getElementById('veditor').value}`
   }
   document.onreadystatechange = (e) => {
     if(document.readyState === 'complete') {
      setTimeout(() => {
        const target = document.getElementsByClassName("vsubmit vbtn")[0]
        target.outerHTML = target.outerHTML
        setTimeout(() => {
          document.getElementsByClassName("vsubmit vbtn")[0].addEventListener('click', gotoComment)
          console.log("event replaced")
        }, 1000)
        document.getElementsByClassName("power txt-right")[0].innerHTML = "Once powered by Valine"
      }, 1000)
     }
   }
 </script></div><footer><p class="site-info"> 博客已萌萌哒运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span><br> Theme - <a target="_blank" href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With 💗 | Powered by GodBMW & hellflame<br></p></footer><script src="/js/footer.js"></script><script>updateUptime(2016,3,27)</script><div class="back-to-top hidden"><span><i class="iconfont icon-60"></i><span></span> %</span></div><script src="/js/component/back-to-top.js"></script></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script src="/js/mathjax.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.js" async></script><script async src="/js/fancybox.js"></script></body></html>