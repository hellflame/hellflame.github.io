<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>Python 调优策略 | Hellflame</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="basics,python,"><meta name="description" content="pleased or sad, everything dies with hellflame"><link rel="alternate" href="/atom.xml" title="Hellflame" type="application/atom+xml"><link rel="icon" href="/images/favicon.png"><link rel="apple-touch-icon" href="/images/favicon.png"><link href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.css" rel="stylesheet"><link rel="stylesheet" href="/css/base.css"><link rel="stylesheet" href="/icon/iconfont.css"><link rel="stylesheet" href="/css/github-markdown.css"><link rel="stylesheet" href="/css/highlight.css"><script src="/js/util.js"></script><script src="/js/valine.min.js"></script><link href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js" async></script><script src="/js/player.js"></script><link href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css" rel="stylesheet"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script></head><body><div id="app"><div class="header-wrap"><header><div class="site-brand"><div class="site-title"> <a href="/">Hellflame</a></div></div><nav class="site-navigation"><ul class="nav-menu"><li class="nav-item" data-path="/"> <a href="/" target="_self">首页</a></li><li class="nav-item" data-path="/archives/"> <a href="/archives/" target="_self">归档</a></li><li class="nav-item" data-path="/categories/"> <a href="/categories/" target="_self">分类</a></li><li class="nav-item" data-path="/tags/"> <a href="/tags/" target="_self">标签</a></li><li class="nav-item" data-path="/friends/"> <a href="/friends/" target="_self">友链</a></li><li class="nav-item" data-path="/about/"> <a href="/about/" target="_self">关于</a></li><li class="nav-item" data-path="https://github.com/hellflame"> <a href="https://github.com/hellflame" target="_self">Github</a></li></ul></nav><i class="iconfont icon-menu"></i></header></div><script src="/js/navigation.js"></script><div class="container post-index"><div class="post"><div style="position:fixed;right:1em;top:1.5em;cursor:pointer;z-index:999" onclick="toggleTOC()" id="toc"><div style="width:2em;height:2em"><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div><div style="width:100%;height:3px;background:silver;margin-bottom:3px"></div></div></div><h1 class="article-title"> <span>Python 调优策略</span></h1><div class="article-top-meta"> <span>发布 : 2017-10-06</span> <span>分类 : <a href="/categories/basics/">basics</a></span> <span>浏览 : <span class="article-timer">--</span></span></div><div class="article-content"><div class="markdown-body"><h3 id="i-理解程序"><a href="#i-理解程序" class="headerlink" title="i. 理解程序"></a>i. 理解程序</h3><p>进行任何优化之前，需要知道通过优化程序的某个部分所获得的加速与该部分所占的执行时间直接相关。例如，如果优化一个函数，使其运行速度变成了原来的10倍，但该函数的执行时间仅占程序总时间的10%，那么将仅能获得9%～10%的总体加速。根据执行优化所涉及的工作，这种优化成果可能并不值得一提。</p><p>首先在要有优化的代码上使用探测模块是一种不错的做法。你其实只想关注占用程序大部分执行时间的函数和方法，而不是偶尔调用的次要操作。</p><blockquote><p>a. 理解算法</p></blockquote><p>即使是糟糕的O(<em>n</em>log n)算法实现也会比经过最优化的O(n^3)算法性能更高。不要优化低效的算法，首先应查找更好的算法</p><blockquote><p>b. 使用内置类型</p></blockquote><p>Python 内置的元组、列表、集合和字典类型完全是用C实现的，而且是解释器中经过最好优化的数据结构。应该积极使用这些类型来存储和操作程序中的数据，尽量避免构建自定义数据结构(如二进制搜索树、链表等)来模仿他们的功能。</p><p>根据这一标准，还应该积极使用标准库中的类型。一些库模块提供的新类型在处理特定任务上比内置类型性能更高。例如，<em>collection.deque</em> 类型提供了与列表类似的功能，但针对在两端插入新项进行了高度优化。相反，列表只有在末尾附近附加项目时才具有较高的效率。如果在前端插入项，需要移动所有其他元素来腾出空间。执行这一操作所需的时间会随着列表的不断变大而增长。</p><h3 id="ii-不要添加层"><a href="#ii-不要添加层" class="headerlink" title="ii. 不要添加层"></a>ii. 不要添加层</h3><p>任何时候像对象或函数添加额外的抽象或便利层，都会降低程序的运行速度。但是，也需要在可用性和性能之间进行权衡。例如，添加额外层的总体目标通常是为了简化编码，这是不错的目标。</p><p>为了技能型掩饰，我们根除一个简单的例子，设想一个程序使用 <em>dict()</em> 函数来创建具有字符串健的字典，如下所示:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = dict(name=<span class="string">"GOOD"</span>, shares=<span class="number">100</span>, price=<span class="number">20.10</span>)</span><br><span class="line"><span class="comment"># s = &#123;'name': 'GOOD', 'shares': 100, 'price': 20.10&#125;</span></span><br></pre></td></tr></table></figure><p>程序员可能以这种方式创建字典来节省键入操作。但是，这种创建字典的替代方法运行速度非常慢，因为它添加了额外的函数调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [5]: timeit.timeit(<span class="string">"s = dict(name='GOOD', shares=100, price=20.10)"</span>)</span><br><span class="line">Out[5]: 0.34595608711242676</span><br><span class="line"></span><br><span class="line">In [6]: timeit.timeit(<span class="string">"s = &#123;'name': 'GOOD', 'shares': 100, 'price': 20.10&#125;"</span>)</span><br><span class="line">Out[6]: 0.14834189414978027</span><br></pre></td></tr></table></figure><p>如果程序在运行时创建了数百万个字典，那么你应该知道第二种方法更快。在绝大多数情况下，添加增强或更改现有Python对象工作方式的任何功能在运行速度上都比较慢。</p><h3 id="iii-了解如何基于字典构建类和实例"><a href="#iii-了解如何基于字典构建类和实例" class="headerlink" title="iii. 了解如何基于字典构建类和实例"></a>iii. 了解如何基于字典构建类和实例</h3><p>用户定义的类和实例时用字典构建的。因此，查找、设置或删除实例数据的速度几乎总是比直接在字典上执行这些操作更慢。如果要做的只是构建一个简单的数据结构来存储数据，字典可能是比定义一个类更有效的选择。</p><p>为了掩饰两者间的差异，这里给出了一个简单的类来表示所持有的股票：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, shares, price)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.shares = shares</span><br><span class="line">    self.price = price</span><br></pre></td></tr></table></figure><p>如果比较实用该类与实用字典的性能，结果会非常有趣。首先，让我们比较一下创建实例的性能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit(<span class="string">"s = Stock('GOOD', 100, 23.12)"</span>, <span class="string">"from stock import Stock"</span>)</span><br><span class="line"><span class="number">0.5397681969916448</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit(<span class="string">"s = &#123;'name': 'GOOD', 'shares': 100, 'price': 23.12&#125;"</span>)</span><br><span class="line"><span class="number">0.1203777749906294</span></span><br></pre></td></tr></table></figure><p>接下来看一下执行简单计算的性能:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit(<span class="string">"s.shares * s.price"</span>, <span class="string">"from stock import Stock; s = Stock('GOOD', 100, 23.12)"</span>)</span><br><span class="line"><span class="number">0.1267336860182695</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit(<span class="string">"s['shares'] * s['price']"</span>, <span class="string">"s = &#123;'name': 'GOOD', 'shares': 100, 'price': 23.12&#125;"</span>)</span><br><span class="line"><span class="number">0.08541777002392337</span></span><br></pre></td></tr></table></figure><p>出现这种情况是因为，可以使用class定义新对象，但这并不是处理数据的唯一途径。元素和字典通常就够用了。使用它们会是程序运行更快并且占用更少的内存。</p><h3 id="iv-使用-slots"><a href="#iv-使用-slots" class="headerlink" title="iv. 使用__slots__"></a>iv. 使用__slots__</h3><p>如果程序创建了用户定义累的大量实例，可以考虑在类定义中使用 __slots__ 属性。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span><span class="params">(object)</span>:</span></span><br><span class="line">  __slots__ = [<span class="string">'name'</span>, <span class="string">'shares'</span>, <span class="string">'price'</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, shares, price)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.shares = shares</span><br><span class="line">    self.price = price</span><br></pre></td></tr></table></figure><p>__slots__ 又是被看作一种安全功能，因为它能限制属性名称的设置。但是，它更主要的用途是在性能优化。使用 __slots__ 的类不使用字典存储实例数据，而是用一种更高效的内部数据结构。所以，不仅实例使用的内存少得多，而且访问实例数据的效率要更高。在某些情况下，仅仅添加 __slots__ 而不进行其他任何更改就会是程序的运行速度显著提高。</p><p>但是，使用 __slots__ 时有一个地方值得注意。将该功能添加到类中可能会无故破坏其他代码。例如，众所周知，实例将他们的数据存储在可作为 __dict__ 属性访问的字典中。定义slots时，该属性还不存在，所以依赖 __dict__ 的任何代码都会失败。</p><h3 id="v-避免使用-运算符"><a href="#v-避免使用-运算符" class="headerlink" title="v. 避免使用 (.) 运算符"></a>v. 避免使用 (.) 运算符</h3><p>使用 (.) 在对象上查找属性时，总是会涉及名称查找。例如，如果使用<code>x.name</code> , 将在环境中查找变量名称 x，然后在x上查找属性name。对于用户定义对象，属性查找还可能涉及在实例字典、类字典和积累的字典中查找。</p><p>对于大量使用方法或模块查找的计算，最好首先将要执行的操作放在一个局部变量中，从而避免属性查找。例如，如果执行大量求平方根操作，使用 <code>from math import sqrt</code> 和 <code>sqrt(x)</code> 比键入 <code>math.sqrt(x)</code> 更快。</p><p>显然，不应该尝试在程序的所有位置消除属性查找，因为这会使代码非常难以理解。但是，对于注重性能的部分，这是一种有用的技术。</p><h3 id="vi-使用异常来处理不常见的情况"><a href="#vi-使用异常来处理不常见的情况" class="headerlink" title="vi. 使用异常来处理不常见的情况"></a>vi. 使用异常来处理不常见的情况</h3><p>要避免错误，你可能需要向程序中添加额外的检查。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_header</span><span class="params">(line)</span>:</span></span><br><span class="line">  fields = line.split(<span class="string">":"</span>)</span><br><span class="line">  <span class="keyword">if</span> len(fields) != <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">"Malformed header"</span>)</span><br><span class="line">  header, value = fields</span><br><span class="line">  <span class="keyword">return</span> header.lower(), value.strip()</span><br></pre></td></tr></table></figure><p>但是，还可以采用另一种方法来处理错误，那就是让程序生成异常并捕获它。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_header</span><span class="params">(line)</span>:</span></span><br><span class="line">  fields = line.split(<span class="string">":"</span>)</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    header, value = fields</span><br><span class="line">    <span class="keyword">return</span> header.lower(), value.strip()</span><br><span class="line">  <span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">"Malformed header"</span>)</span><br></pre></td></tr></table></figure><p>如果在格式正确的行上对两个版本的代码进行基准测试，会发现第二个代码的运行速度更快。为在正常情况下不抛出异常的代码设置try代码块，这通常比执行if语句更快。</p><h3 id="vii-避免对常见的情况使用异常"><a href="#vii-避免对常见的情况使用异常" class="headerlink" title="vii. 避免对常见的情况使用异常"></a>vii. 避免对常见的情况使用异常</h3><p>不要在代码中对常见情况进行一场处理。例如，假设一个程序执行了大量字典查找，但大部分查找操作都是在查找不存在的键。现在，可以考虑两种执行查找的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1:执行查找并捕获异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  value = items[key]</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">  value = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2:检查键是否存在，然后执行查找</span></span><br><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> items:</span><br><span class="line">  value = items[key]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  value = <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p>在简单的性能测试中(假设没有找到所需的键)，第二种方法的运行速度比第一种方法快数倍，而且，第二种方法的运行速度几乎是用 items.get(key) 的两倍，因为 in 运算符的执行速度比方法调用更快。</p><h3 id="viii-鼓励使用函数式编程和迭代"><a href="#viii-鼓励使用函数式编程和迭代" class="headerlink" title="viii. 鼓励使用函数式编程和迭代"></a>viii. 鼓励使用函数式编程和迭代</h3><p>列表包含、生成器表达式、生成器、协程和闭包比大多数Python程序员想象的要更为高效。尤其对于数据处理而言，与手动迭代数据并执行类似操作的代码相比，列表包含和生成器表达式的运行速度要快得多。这些操作的运行速度也比使用map() 和 filter() 等函数的旧式 Python 代码快得多。使用生成器编写的代码不仅能够最快的运行，还能够搞笑的使用内存。</p><h3 id="ix-使用装饰器和元类"><a href="#ix-使用装饰器和元类" class="headerlink" title="ix. 使用装饰器和元类"></a>ix. 使用装饰器和元类</h3><p>装饰器和元类用于修改函数和类。但是，由于它们在定义函数或类时进行操作，所以可以通过多种方式使用它们来改进性能，特别是程序拥有很多可以启动和禁用的可选功能时。</p><blockquote><p>节选自 <em>《Python参考手册(第四版)》- 调优与优化</em></p></blockquote></div></div><div class="copy-right"><div class="markdown-body"><blockquote> 本文作者 : hellflame<br> 原文链接 : <a href="">https://hellflame.github.io/2017/10/06/python-optimize/</a><br> 版权声明 : 本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</blockquote></div></div><div class="social-share" style="margin-top:-2rem" data-wechat-qrcode-title="<p>微信扫一扫</p>" data-wechat-qrcode-helper="<p>微信右上角, 扫一扫分享</p>" data-sites="qzone, qq, weibo, facebook, twitter"> <span style="color:#6b7487;font-size:1.4rem">分享到:</span></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js" async></script><div class="article-footer"><div class="article-meta pull-left"><span><i class="iconfont icon-06tags"></i> 标签: <span class="span--tag"><a href="/tags/python/">#python</a></span></span></div><div class="article-meta pull-right"></div></div></div><aside id="sidebar"><p id="sidebar-header"></p><ol id="sidebar-toc"></ol></aside><script async>getTOC().length||$("#toc").remove()</script><nav class="post-navigation"><div class="nav-pre"><i class="iconfont icon-prev"></i> 上一篇: <a href="/2017/10/02/my-http-connector/" target="_self">我的HTTP下载库</a></div><div class="nav-next"> 下一篇: <a href="/2017/12/06/block-tornado/" target="_self">阻塞的Tornado</a><i class="iconfont icon-next"></i></div></nav><a href="#comment" class="comment-anchor"></a><div class="comment-title"><i class="iconfont icon-footprint"></i> 留下足迹<i class="iconfont icon-footprint"></i></div> <a style="margin-bottom:1em;display:block;cursor:pointer" onclick="gotoComment()">点击通过issue留言</a><div id="vcomments"></div><script defer="defer">new Valine({el:"#vcomments",appId:"a",appKey:"b",notify:!1,verify:!1,avatar:"robohash",placeholder:"不填邮箱，网址, 也能收到回复哦♪(^∇^*)\n当然也不一定会回复-_-",path:getRealPath()})</script><script defer="defer">
   function gotoComment() {
    location.href = `https://github.com/hellflame/hellflame.github.io/issues/new?title=关于%0A“Python%20%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5”&body=%23%23%23%20[原文地址](https://hellflame.github.io/2017/10/06/python-optimize/)%0A%0A%23%23%23%20想说的话(问题/支持/异议)%20%20%0A%0A${document.getElementById('veditor').value}`
   }
   document.onreadystatechange = (e) => {
     if(document.readyState === 'complete') {
      setTimeout(() => {
        const target = document.getElementsByClassName("vsubmit vbtn")[0]
        target.outerHTML = target.outerHTML
        setTimeout(() => {
          document.getElementsByClassName("vsubmit vbtn")[0].addEventListener('click', gotoComment)
          console.log("event replaced")
        }, 1000)
        document.getElementsByClassName("power txt-right")[0].innerHTML = "Once powered by Valine"
      }, 1000)
     }
   }
 </script></div><footer><p class="site-info"> 博客已萌萌哒运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span><br> Theme - <a target="_blank" href="https://github.com/dongyuanxin/theme-bmw">BMW</a> | Made With 💗 | Powered by GodBMW & hellflame<br></p></footer><script src="/js/footer.js"></script><script>updateUptime(2016,3,27)</script><div class="back-to-top hidden"><span><i class="iconfont icon-60"></i><span></span> %</span></div><script src="/js/component/back-to-top.js"></script></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script src="/js/mathjax.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.6/dist/jquery.fancybox.min.js" async></script><script async src="/js/fancybox.js"></script></body></html>